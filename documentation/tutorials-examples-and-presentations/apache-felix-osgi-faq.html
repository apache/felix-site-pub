<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE- 2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
  <head>
    <title>Apache Felix - OSGi Frequently Asked Questions</title>
    <link rel="icon" href="/res/favicon.ico">
    <link rel="stylesheet" href="/res/site.css" type="text/css" media="all">
    <link rel="stylesheet" href="/res/codehilite.css" type="text/css" media="all">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </head>
  <body>
    <div class="title">
      <div class="logo">
        <a href="http://felix.apache.org/">
          <img border="0" alt="Apache Felix" src="/res/logo.png">
        </a>
      </div>
      <div class="header">
        <a href="http://www.apache.org/">
          <img border="0" alt="Apache" src="/res/apache.png">
        </a>
      </div>
    </div>
    
    <div class="menu"> 
      <style type="text/css">
/* The following code is added by mdx_elementid.py
   It was originally lifted from http://subversion.apache.org/style/site.css */
/*
 * Hide class="elementid-permalink", except when an enclosing heading
 * has the :hover property.
 */
.headerlink, .elementid-permalink {
  visibility: hidden;
}
h2:hover > .headerlink, h3:hover > .headerlink, h1:hover > .headerlink, h6:hover > .headerlink, h4:hover > .headerlink, h5:hover > .headerlink, dt:hover > .elementid-permalink { visibility: visible }</style>
<p><a href="/news.html">News</a>  <br />
<a href="/license.html">License</a>  <br />
<a href="/downloads.cgi">Downloads</a>  <br />
<a href="/documentation.html">Documentation</a>  <br />
<a href="/mailinglists.html">Mailing Lists</a>  <br />
<a href="/documentation/community/contributing.html">Contributing</a>  <br />
<a href="/sitemap.html">Site Map</a>  <br />
<a href="http://www.apache.org/">ASF</a>  <br />
<a href="http://www.apache.org/security/">Security</a>  <br />
<a href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a>  <br />
<a href="http://www.apache.org/foundation/thanks.html">Sponsors</a>    </p>
<iframe
    src="http://www.apache.org/ads/button.html"
    style="border-width:0; float: left"
    frameborder="0"
    scrolling="no"
    width="135"
    height="135">
</iframe>
    </div>
    
    <div class="main">
      <div class="breadcrump" style="font-size: 80%;">
        <a href="/">Home</a>&nbsp;&raquo&nbsp;<a href="/documentation.html">Documentation</a>&nbsp;&raquo&nbsp;<a href="/documentation/tutorials-examples-and-presentations.html">Tutorials, Examples, and Presentations</a>
      </div>

      <h1>OSGi Frequently Asked Questions</h1>
      <style type="text/css">
/* The following code is added by mdx_elementid.py
   It was originally lifted from http://subversion.apache.org/style/site.css */
/*
 * Hide class="elementid-permalink", except when an enclosing heading
 * has the :hover property.
 */
.headerlink, .elementid-permalink {
  visibility: hidden;
}
h2:hover > .headerlink, h3:hover > .headerlink, h1:hover > .headerlink, h6:hover > .headerlink, h4:hover > .headerlink, h5:hover > .headerlink, dt:hover > .elementid-permalink { visibility: visible }</style>
<div class="toc">
<ul>
<li><a href="#if-i-use-bundles-from-felix-will-my-application-be-tied-to-the-felix-framework">If I use bundles from Felix, will my application be tied to the Felix framework?</a></li>
<li><a href="#when-i-update-my-bundle-why-are-my-bundles-old-classes-still-being-used">When I update my bundle, why are my bundle's old classes still being used?</a></li>
<li><a href="#should-a-service-providerconsumer-bundle-be-packaged-with-its-service-api-packages">Should a service provider/consumer bundle be packaged with its service API packages?</a></li>
<li><a href="#should-a-bundle-import-its-own-exported-packages">Should a bundle import its own exported packages?</a></li>
<li><a href="#why-is-my-bundle-not-able-to-see-annotations-at-run-time">Why is my bundle not able to see annotations at run time?</a></li>
<li><a href="#how-to-provide-optional-services">How to provide optional services?</a></li>
</ul>
</div>
<h2 id="if-i-use-bundles-from-felix-will-my-application-be-tied-to-the-felix-framework">If I use bundles from Felix, will my application be tied to the Felix framework?<a class="headerlink" href="#if-i-use-bundles-from-felix-will-my-application-be-tied-to-the-felix-framework" title="Permanent link">&para;</a></h2>
<p>No. The Felix community is very serious about creating technology that is "pure" OSGi. This means that we will always strive to make sure our subprojects work on all OSGi framework implementations. The Felix framework provides very few "containerisms", so there are generally no "special" Felix features available on which subprojects may depend. Even though it is common to use the name "Felix" to refer to the Felix framework, in reality the framework is just one subproject in the Apache Felix project. All subprojects are intended to be used either together or separately.</p>
<p>Note that not all subprojects are tested on all available OSGi framework implementations, but it is the goal for them to run on them. Any difficulties in doing so should be filed as bugs in <a href="http://issues.apache.org/jira/browse/FELIX">JIRA</a>. Additionally, due to specification ambiguity, it is possible the Felix framework may exhibit different behavior than other implementations, but this is normal; if in doubt, file a bug. In the future, it is also possible some subprojects may require Felix, but they will explicitly state this fact.</p>
<h2 id="when-i-update-my-bundle-why-are-my-bundles-old-classes-still-being-used">When I update my bundle, why are my bundle's old classes still being used?<a class="headerlink" href="#when-i-update-my-bundle-why-are-my-bundles-old-classes-still-being-used" title="Permanent link">&para;</a></h2>
<p>Updating a bundle does not necessarily cause the new classes to be used immediately, it depends on two factors:</p>
<ol>
<li>If the classes are from a private package or an exported package.</li>
<li>If the classes are from an exported package, whether or not they are being used by another bundle.</li>
</ol>
<p>Regarding (1), if the classes come from a private package (i.e., it is <strong>not</strong> exported), then the new classes will become available immediately. However, if they are from an exported package, then their visibility depends on whether any other bundles are using the exported packages.</p>
<p>If no other bundles are using the exported packages, then the new classes will become available immediately since the old version of the classes are no longer needed. On the other hand, if any other bundles are using the exported packages, then the new classes will <strong>not</strong> become available immediately since the old version is still required by any dependent bundles. In this case, the new classes will not be made available until <code>PackageAdmin.refreshPackages()</code> is called (this can be invoked in the Felix shell using the <code>refresh</code> command). </p>
<p>There is one partial exception to this latter case, it occurs when the exporting bundle does <strong>not</strong> also import its own exported packages (see "<a href="#should-a-bundle-import-its-own-exported-packages">Should a bundle import its own exported packages?</a>" below for more information on this topic). In this case, the new classes become immediately accessible to the updated exporting bundle, but not to the dependent bundles; the dependent bundles continue to see the old version of the classes. This situation generally requires <code>PackageAdmin.refreshPackages()</code> to be invoked to bring the bundles back to a useful state.</p>
<p>This is the normal update process as defined by the OSGi specification. Updating a bundle is a two-step process, where older versions of exported packages are kept around until explicitly refreshed. This is done to reduce disruption when performing several updates.</p>
<h2 id="should-a-service-providerconsumer-bundle-be-packaged-with-its-service-api-packages">Should a service provider/consumer bundle be packaged with its service API packages?<a class="headerlink" href="#should-a-service-providerconsumer-bundle-be-packaged-with-its-service-api-packages" title="Permanent link">&para;</a></h2>
<p>There is no easy answer to this question and it largely depends on the specific usage scenario. The OSGi specification had originally suggested that it was good practice to embed service API packages in the service provider bundle. In this case in OSGi R4, the service provider should both <a href="#should-a-bundle-import-its-own-exported-packages">export and import</a> the service API packages, which was the default for previous versions of the OSGi specification.</p>
<p>The OSGi specification never had an explicit stance on whether or not a consumer bundle should embed its dependent service API packages; although, it would not appear to be a best practice. Logically, there is some sense to this approach, since it potentially allows the consumer bundle to gracefully handle broken service dependencies. Of course, this depends on whether there is anything the bundle can do in the face of broken dependencies. If service API packages are embedded in the consumer bundle, then it should <a href="#should-a-bundle-import-its-own-exported-packages">export and import</a> the packages. An alternative approach in this case is to dynamically import the service API (or even use optional imports if the dependency should only be considered once).</p>
<p>The main advantages of embedding service API packages in bundles are that the dependencies can always be resolved and it does not require installing a lot of other bundles to resolve the dependencies. There are disadvantages, however. One disadvantage is resource consumption caused by potential code duplication. Probably a more serious disadvantage is that it makes it harder to dynamically swap out providers.</p>
<p>For example, assume a provider bundle is used to export service API packages and all consumers are wired to that bundle. If the provider bundle is updated or uninstalled and then refreshed, then all consumer bundles will be stopped and refreshed as well. Even without a refresh, such a configuration would potentially inhibit garbage collection of the class loader of the service provider, since consumers would be using it for the API package.</p>
<p>This situation would be different if the service API were package in a separate bundle. In this situation, all consumer bundles would be wired to the API bundle, not to the provider bundle. Thus, if the provider were updated or uninstalled and then refreshed, the consumer bundles would only be minimally impacted (i.e., they would either switch to the new version of the provider or to a different provider).</p>
<h2 id="should-a-bundle-import-its-own-exported-packages">Should a bundle import its own exported packages?<a class="headerlink" href="#should-a-bundle-import-its-own-exported-packages" title="Permanent link">&para;</a></h2>
<p>In OSGi R3 this was always the case, since Export-Package implied Import-Package. It was a good idea then and is generally a good idea now.</p>
<p>The whole point is substitutability of providers.</p>
<p>If you import the packages you export, then the framework is free to choose a different provider of those packages for your bundle at resolve time, which means that your exports may go unused. However, this is a good thing, because the framework tries to minimize the number of active versions of a given package. The reason why this is a good thing is because it allows for higher levels of bundle interoperability. The more versions of a given package that are in use at any given time can lead to conflicts when trying to resolve bundle package dependencies and this also leads to partitioning of the service registry, since bundles can only see a single version of a given service package.</p>
<p>If your bundle only exports its packages, then it is forcing the framework to wire itself to its own version, which will result in more active versions of the given package and thus less interoperability.</p>
<p>The main time you want to export only, is if your bundle is purely a library bundle, then its packages will only be used if they are needed. Another case might be if you have tightly coupled bundles sharing implementation packages. However, if your bundle will be started and especially if the exported packages define service interfaces or are referenced from service interfaces, then you will generally want to export and import them.</p>
<h2 id="why-is-my-bundle-not-able-to-see-annotations-at-run-time">Why is my bundle not able to see annotations at run time?<a class="headerlink" href="#why-is-my-bundle-not-able-to-see-annotations-at-run-time" title="Permanent link">&para;</a></h2>
<p>This is typically a class loading issue. At runtime the JVM will only return annotations that are visible to the current class loader, so if your bundle doesn't import the appropriate package(s) then you won't see them.</p>
<p>This is not a bug, as such, it is simply how OSGi class loading works - your bundle cannot see classes that its hasn't imported (or acquired via <code>Require-Bundle</code>). It is also part of the design of annotations, since annotated classes are supposed to continue to load and resolve even if their annotation types aren't available on the class path. This lets you annotate a class with EJB3 annotations, for example, but also use it in a non-EJB container where you won't then see the EJB3 annotations.</p>
<p>Try importing the annotation package inside your bundle to resolve the visibility issue.</p>
<h2 id="how-to-provide-optional-services">How to provide optional services?<a class="headerlink" href="#how-to-provide-optional-services" title="Permanent link">&para;</a></h2>
<p>Imagine a bundle wants to provide a service only if a consumer is actually
using the service. To increase the complexity lets assume the API for the
optional service may not always be available. So assuming there is no
service consumer, the bundle should not fail to start if the API is not
available.</p>
<p>Lets illustrate with a concrete example: Consider a bundle executes some
business logic. Optionally the bundle provides information through the
<a href="/documentation/subprojects/apache-felix-web-console.html">Apache Felix Web Console</a>. The
bundle should resolve and be active regardless of whether the web console is
present or not.</p>
<p>The OSGi Core specification has two helpful mechanism at hand for these
situations: <code>ServiceFactory</code> and <code>DynamicImport-Package</code>. With the <code>ServiceFactory</code>
a place holder object is registered with the Service Registry instead of
the actual service object. Only when the service is actually requested, will
the <code>ServiceFactory</code> create the service object.</p>
<p>The second mechanism is a bit frowned upon in the OSGi community because it
has the potential to be overused and thus break the promise of OSGi to be
explicit with the requirements of a bundle. In the specific context we are
using the <code>DynamicImport-Package</code>, though, I think it is worth using. This
mechanism allows deferring to wire a particular package to the moment, the
respective API is actually used.</p>
<p>Here's how to implement the the example from above:</p>
<p>(1) Create a <code>ServiceFactory</code></p>
<div class="codehilite"><pre><span class="kd">private</span> <span class="kd">class</span> <span class="nc">PluginServiceFactory</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BusinessObject</span> <span class="n">bo</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">bundle</span><span class="o">,</span> <span class="n">ServiceRegistration</span> <span class="n">registration</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BusinessObjectPlugin</span><span class="o">(</span><span class="n">bo</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">ungetService</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">bundle</span><span class="o">,</span> <span class="n">ServiceRegistration</span> <span class="n">registration</span><span class="o">,</span> <span class="n">Object</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// no cleanup required, have GC do the rest</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>(2) Register the service</p>
<div class="codehilite"><pre><span class="n">Hashtable</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="s">&quot;Business Object&quot;</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="s">&quot;bo&quot;</span><span class="o">);</span>
<span class="n">bundleContext</span><span class="o">.</span><span class="na">registerService</span><span class="o">(</span><span class="s">&quot;javax.servlet.Servlet&quot;</span><span class="o">,</span>
    <span class="k">new</span> <span class="nf">PluginServiceFactory</span><span class="o">(</span><span class="n">bo</span><span class="o">),</span>
    <span class="n">props</span><span class="o">);</span>
</pre></div>


<p>(3) Dynamically import the API</p>
<div class="codehilite"><pre>DynamicImport-Package: javax.servlet;javax.servlet.http;version=2.3
</pre></div>


<p>For an example of using this pattern, you might want to look at the
<a href="http://svn.apache.org/repos/asf/felix/trunk/jaas">Apache Felix JAAS bundle</a>,
particularly the <a href="http://svn.apache.org/repos/asf/felix/trunk/jaas/pom.xml">POM File</a>
and the <a href="http://svn.apache.org/repos/asf/felix/trunk/jaas/src/main/java/org/apache/felix/jaas/internal/Activator.java">Activator class</a> with the <code>ServiceFactory</code>.</p>
      <div class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
        Rev. 1461645 by fmeschbe on Wed, 27 Mar 2013 15:22:53 +0000
      </div>
      <div class="trademarkFooter"> 
        Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project
        logo are trademarks of The Apache Software Foundation. All other marks mentioned
        may be trademarks or registered trademarks of their respective owners.
      </div>
    </div>
  </body>
</html>

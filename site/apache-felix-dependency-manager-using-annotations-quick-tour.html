
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Felix - Apache Felix Dependency Manager - Using Annotations - Quick Tour</TITLE>
    <LINK rel="stylesheet" href="http://felix.apache.org/site/media.data/site.css" type="text/css" media="all">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY>
    <DIV class="title"><DIV class="logo"><A href="http://felix.apache.org/site/index.html"><IMG border="0" alt="Apache Felix" src="http://felix.apache.org/site/media.data/logo.png"></A></DIV><DIV class="header"><A href="http://www.apache.org/"><IMG border="0" alt="Apache" src="http://felix.apache.org/site/media.data/apache.png"></A></DIV></DIV>
    <DIV class="menu">
<UL>
	<LI><A href="news.html" title="news">news</A></LI>
	<LI><A href="http://www.apache.org/licenses/" class="external-link" rel="nofollow">license</A></LI>
	<LI><A href="http://felix.apache.org/site/downloads.cgi" class="external-link" rel="nofollow">downloads</A></LI>
	<LI><A href="documentation.html" title="documentation">documentation</A></LI>
	<LI><A href="mailinglists.html" title="mailinglists">mailing lists</A></LI>
	<LI><A href="contributing.html" title="Contributing">contributing</A></LI>
	<LI><A href="http://www.apache.org/" class="external-link" rel="nofollow">asf</A></LI>
	<LI><A href="http://www.apache.org/security/" class="external-link" rel="nofollow">security</A></LI>
	<LI><A href="http://www.apache.org/foundation/sponsorship.html" class="external-link" rel="nofollow">sponsorship</A></LI>
	<LI><A href="http://www.apache.org/foundation/thanks.html" class="external-link" rel="nofollow">sponsors</A>
<!-- ApacheCon Ad -->
<IFRAME src="http://www.apache.org/ads/button.html" style="border-width:0; float: left" frameborder="0" scrolling="no" width="135" height="135"></IFRAME>
<P style="height: 100px">
<!-- ApacheCon Ad --></LI>
</UL>
    </DIV>
    <DIV class="main">
<H1><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-SpellCheckerSample"></A>Spell Checker Sample</H1>

<P>This section presents a quick overview of the capabilities and usage  of  the DependencyManager java 5 annotations. In particular, we will  recap  the DependencyManager annotation architecture, and identify some&nbsp;  simple usage  scenarios using a SpellChecker sample application with  annotated  components (the application is available from the felix  trunk, in the  dependencymanager/samples.annotation maven subproject).</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-Architecture"></A>Architecture</H2>

<P>Instead of writing Activators which extends the DependencyActivatorBase class, service components can now be annotated using the annotations provided by the <EM>org.apache.felix.dependencymanager.annotation</EM> bundle. Annotations are not reflectively parsed at runtime; but we use a BND plugin which scans annotations at compilation phase and generates a compact metadata file in the bundle's META-INF/dependencymanager subdirectory. This has the following benefits:</P>
<UL>
	<LI>JVM startup speed is not affected, and class files are not parsed when the framework is starting</LI>
	<LI>Moreover, since the annotations are not retained by the VM at runtime, it is not necessary to load the annotation API bundle at runtime.</LI>
</UL>


<P>At runtime, the metadata generated during the compilation phase are processed by a specific DependencyManager Runtime bundle, which is in charge of managing the service component lifecycle and dependencies. This Runtime bundle actually uses the DependencyManager programmatic API in order to manage the annotated components. Annotated components can then be inspected with the DependencyManager Gogo shell, as it is the case with DM components declared through the programmatic DM API.</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-RegisteringaService"></A>Registering a Service</H2>

<P>To register a service, your can annotate your class with a <EM>@Component</EM> annotation, and an instance of your class will be registered under all directly implemented interfaces into the OSGi registry. You can however take control on the interfaces to be exposed, and in this case, you can use the <EM>provides</EM> attribute, which takes a list of classes to expose from the registry.</P>

<P>To illustrate this, we are now introducing a SpellChecker application which provides a Felix &quot;spellcheck&quot; Gogo shell command. Gogo is the  new shell supported by the Felix Framework. Our &quot;spellcheck&quot; command is implemented by the SpellChecker component which accepts a string as  parameter. This string is then checked for proper existence. To do the  checking, The SpellChecker class has a required/multiple (1..N) dependency over every available DictionaryService services. Such DictionaryService represents a real dictionary for a given language (it  has a <EM>lang</EM> service property), and is configurable/instantiable from Configuration Admin.</P>

<P>The OSGi Configuration Admin service provides a mechanism for configuring components (using ManagedService interfaces), and WebConsole actually implements this service. ConfigAdmin is also able to instantiate some Services (using ManagedServiceFactory interfaces).</P>

<P>Now we have introduced the background, here is the SpellCheck component:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@Component(provides={SpellChecker.class},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   properties={@Property(name=CommandProcessor.COMMAND_SCOPE, value=<SPAN class="code-quote">&quot;dmsample.annotation&quot;</SPAN>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   @Property(name=CommandProcessor.COMMAND_FUNCTION, values={<SPAN class="code-quote">&quot;spellcheck&quot;</SPAN>})})
<SPAN class="code-keyword">public</SPAN> class SpellChecker {
    <SPAN class="code-comment">// --- Gogo Shell command
</SPAN>
&nbsp;&nbsp;&nbsp; @Descriptor(<SPAN class="code-quote">&quot;checks <SPAN class="code-keyword">if</SPAN> word is found from an available dictionary&quot;</SPAN>)
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">public</SPAN> void spellcheck(@Descriptor(<SPAN class="code-quote">&quot;the word to check&quot;</SPAN>)<SPAN class="code-object">String</SPAN> word) {
       <SPAN class="code-comment">// Check the proper existence of the word parameter, using injected DictionaryService instances
</SPAN>       <SPAN class="code-comment">// ...
</SPAN>    }
}
</PRE>
</DIV></DIV>

<P>In the code above, you see that the SpellCheck is annotated with the <EM>@Component</EM> annotation. Gogo runtime does not required shell commands to implement a  specific interface. Commands just have to register some Pojos in the  OSGi registry, but the only thing required is to provide the Pojos with  two service properties ( COMMAND_SCOPE, and COMMAND_FUNCTION) which will  be used by the Gogo runtime when instropecting the Pojo for invoking  the proper functions.</P>


<P>So, coming back to the sample code, the SpellChecker class registers  itself into the OSGi registry, using the <EM>provides</EM> attribute, which just refer to our SpellChecker class, and the two  mandatory Gogo service properties are also specified using the <EM>@Property</EM> annotation. It is not shown here, but service properties can also be  provided dynamically from a method that can return a Map, and annotated  with the <EM>@Start</EM> lifecycle callback, but we will see this feature in a another section.</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-DependingonaService"></A>Depending on a Service</H2>

<P>Our SpellChecker component can expose itself as a Gogo shell command,   but before being registered into the OSGi registry, we also need to be   injected with&nbsp; two dependencies: one required dependency (at minimum)  on  a DictionaryService, and another optional one on a LogService.  First,  let's look at the DictionaryService, which is a simple  interface:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
 <SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> DictionaryService {
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Check <SPAN class="code-keyword">for</SPAN> the existence of a word.
&nbsp;&nbsp;&nbsp;&nbsp; * @param word the word to be checked.
&nbsp;&nbsp;&nbsp;&nbsp; * @<SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">true</SPAN> <SPAN class="code-keyword">if</SPAN> the word is in the dictionary, <SPAN class="code-keyword">false</SPAN> otherwise.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">boolean</SPAN> checkWord(<SPAN class="code-object">String</SPAN> word);
}
</PRE>
</DIV></DIV>
<P>And here is our previous SpellChecker component, augmented with two new ServiceDependency annotations:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@Component(provides={SpellChecker.class},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; properties={@Property(name=CommandProcessor.COMMAND_SCOPE, value=<SPAN class="code-quote">&quot;dmsample.annotation&quot;</SPAN>),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Property(name=CommandProcessor.COMMAND_FUNCTION, values={<SPAN class="code-quote">&quot;spellcheck&quot;</SPAN>})})
<SPAN class="code-keyword">public</SPAN> class SpellChecker {
&nbsp;&nbsp;&nbsp; @ServiceDependency(required = <SPAN class="code-keyword">false</SPAN>)
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> LogService m_log;

&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> CopyOnWriteArrayList&lt;DictionaryService&gt; m_dictionaries = <SPAN class="code-keyword">new</SPAN> CopyOnWriteArrayList&lt;DictionaryService&gt;();

&nbsp;&nbsp;&nbsp; @ServiceDependency(removed = <SPAN class="code-quote">&quot;removeDictionary&quot;</SPAN>)
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">protected</SPAN> void addDictionary(DictionaryService dictionary) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dictionaries.add(dictionary);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">protected</SPAN> void removeDictionary(DictionaryService dictionary) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_dictionaries.remove(dictionary);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <SPAN class="code-comment">// --- Gogo Shell command
</SPAN>
&nbsp;&nbsp;&nbsp; @Descriptor(<SPAN class="code-quote">&quot;checks <SPAN class="code-keyword">if</SPAN> word is found from an available dictionary&quot;</SPAN>)
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">public</SPAN> void spellcheck(@Descriptor(<SPAN class="code-quote">&quot;the word to check&quot;</SPAN>)<SPAN class="code-object">String</SPAN> word)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_log.log(LogService.LOG_INFO, <SPAN class="code-quote">&quot;Checking spelling of word \&quot;</SPAN>&quot; + word
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + <SPAN class="code-quote">&quot;\&quot;</SPAN> using the following dictionaries: &quot; + m_dictionaries);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">for</SPAN> (DictionaryService dictionary : m_dictionaries)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">if</SPAN> (dictionary.checkWord(word))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-object">System</SPAN>.out.println(<SPAN class="code-quote">&quot;word &quot;</SPAN> + word + <SPAN class="code-quote">&quot; is correct&quot;</SPAN>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">return</SPAN>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;word &quot;</SPAN> + word + <SPAN class="code-quote">&quot; is incorrect&quot;</SPAN>);
&nbsp;&nbsp;&nbsp; }
}
</PRE>
</DIV></DIV>
<P>There are many things to describe in the code above:</P>

<P>First, we define an optional dependency on the LogService, by defining a <EM>@ServiceDependency(required=false)</EM> annotation on our m_logService field: This means that our component   will be provided into the OSGi registry even if there is no available   LogService, and in this case, a NullObject will be injected in our class   field; This will avoid to check for nullability, when using the   m_logService field. All optional dependencies applied on class fields  are  injected with a NullObject (when not available). The NullObject can  be  invoked and will do nothing. For a lot of cases  that is good  enough to  handle optional dependencies. But when you really want to  check if an  optional service is there or not, then you have to apply  the optional  dependency on a callback method, which will be called when  the optional  service is available.</P>

<P>Next comes the dependency on the DictionaryService. Here, we use a <EM>ServiceDependency</EM> annotation, but this time we apply it on a method (<EM>add/removeDictionary</EM>). There is no need to specify the &quot;<EM>required=true</EM>&quot;   flag because it is the default value. Notice that this behavior is   different from the API, where service dependencies are optional by   default. We use a callback method, because we just need to register all   available DictionaryService services in our dictionary list, which is   used when checking word existence. This list is a copy on write list   because the dependency may be injected at any time, possibly from   another thread. So, using a copy on write list avoid us to use   synchronized methods.</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-CreatingaServicefromConfigAdmin"></A>Creating a Service from ConfigAdmin</H2>

<P>The <EM>@Component</EM> annotation is not the only one for creating services. Another one is the <EM>@FactoryConfigurationAdapterService</EM> annotation which allows to instantiate many instances of the same   annotated service class from ConfigAdmin (and WebConsole). To illustrate  this, let's take a look at our  DictionaryImpl class which is part of  the SpellChecker sample. This service is required by the SpellChecker  component, when checking for proper word existence. And you can  instantiate as many DictionaryService as you want, from ConfigAdmin ...</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@FactoryConfigurationAdapterService(factoryPid=<SPAN class="code-quote">&quot;DictionaryImplFactoryPid&quot;</SPAN>, updated=<SPAN class="code-quote">&quot;updated&quot;</SPAN>) &nbsp;
<SPAN class="code-keyword">public</SPAN> class DictionaryImpl <SPAN class="code-keyword">implements</SPAN> DictionaryService {
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * We store all configured words in a thread-safe data structure, because ConfigAdmin
&nbsp;&nbsp;&nbsp;&nbsp; * may invoke our updated method at any time.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> CopyOnWriteArrayList&lt;<SPAN class="code-object">String</SPAN>&gt; m_words = <SPAN class="code-keyword">new</SPAN> CopyOnWriteArrayList&lt;<SPAN class="code-object">String</SPAN>&gt;();

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Our Dictionary language.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> <SPAN class="code-object">String</SPAN> m_lang;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Our service will be initialized from ConfigAdmin, and we also handle updates in <SPAN class="code-keyword">this</SPAN> method.
&nbsp;&nbsp;&nbsp;&nbsp; * @param config The configuration where we'll lookup our words list (key=<SPAN class="code-quote">&quot;words&quot;</SPAN>).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">protected</SPAN> void updated(Dictionary&lt;<SPAN class="code-object">String</SPAN>, ?&gt; config) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_lang = (<SPAN class="code-object">String</SPAN>) config.get(<SPAN class="code-quote">&quot;lang&quot;</SPAN>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_words.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-object">String</SPAN>[] words = (<SPAN class="code-object">String</SPAN>[]) config.get(<SPAN class="code-quote">&quot;words&quot;</SPAN>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">String</SPAN> word : words) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_words.add(word);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Check <SPAN class="code-keyword">if</SPAN> a word exists <SPAN class="code-keyword">if</SPAN> the list of words we have been configured from ConfigAdmin/WebConsole.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">boolean</SPAN> checkWord(<SPAN class="code-object">String</SPAN> word) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">return</SPAN> m_words.contains(word);
&nbsp;&nbsp;&nbsp; }
}
</PRE>
</DIV></DIV>
<P>Our DictionaryImpl class implements a DictionaryService, and our  class will be registered under that interface (all directly implemented  interfaces are used when registering the service, but you can select  some others using the <EM>provides</EM> attribute). The <EM>@FactoryConfigurationAdapterService</EM> annotation will instantiate our service for each configuration created  from web console (and matching our &quot;DictionaryImplFactoryPid&quot;  factoryPid).</P>

<P>We also use the <EM>updated</EM> attribute, which specifies a callback  method which will handle properties configured by ConfigAdmin. The  updated callback will also be called when our properties are changing.  Every properties are propagated to our service properties, unless the  properties starting with a dot (&quot;.&quot;). Configuration properties starting  with a dot (&quot;.&quot;) are considered private and are not propagated.</P>

<P>Notice that this annotation also supports optional meta type  attributes, which allow to customize the ConfigAdmin GUI, with custom  messages, like heading/property title, property type, property  description, etc ...). So, let's revisit our DisctionaryImpl service,  but this time with meta type support:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
  @FactoryConfigurationAdapterService(factoryPid=<SPAN class="code-quote">&quot;DictionaryImplFactoryPid&quot;</SPAN>,
&nbsp;&nbsp;&nbsp; propagate=<SPAN class="code-keyword">true</SPAN>,
&nbsp;&nbsp;&nbsp; updated=<SPAN class="code-quote">&quot;updated&quot;</SPAN>,
&nbsp;&nbsp;&nbsp; heading=<SPAN class="code-quote">&quot;Dictionary Services&quot;</SPAN>,
&nbsp;&nbsp;&nbsp; description=<SPAN class="code-quote">&quot;Declare here some Dictionary instances, allowing to instantiates some DictionaryService services <SPAN class="code-keyword">for</SPAN> a given dictionary language&quot;</SPAN>,
&nbsp;&nbsp;&nbsp; metadata={
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PropertyMetaData(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heading=<SPAN class="code-quote">&quot;Dictionary Language&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description=<SPAN class="code-quote">&quot;Declare here the language supported by <SPAN class="code-keyword">this</SPAN> dictionary. &quot;</SPAN> +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-quote">&quot;This property will be propagated with the Dictionary Service properties.&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaults={<SPAN class="code-quote">&quot;en&quot;</SPAN>},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id=<SPAN class="code-quote">&quot;lang&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cardinality=0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PropertyMetaData(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heading=<SPAN class="code-quote">&quot;Dictionary words&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description=<SPAN class="code-quote">&quot;Declare here the list of words supported by <SPAN class="code-keyword">this</SPAN> dictionary.&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaults={<SPAN class="code-quote">&quot;hello&quot;</SPAN>, <SPAN class="code-quote">&quot;world&quot;</SPAN>},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id=<SPAN class="code-quote">&quot;words&quot;</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cardinality=<SPAN class="code-object">Integer</SPAN>.MAX_VALUE)
&nbsp;&nbsp;&nbsp; }
) &nbsp;
<SPAN class="code-keyword">public</SPAN> class DictionaryImpl <SPAN class="code-keyword">implements</SPAN> DictionaryService {
    ... code same as before
}
</PRE>
</DIV></DIV>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-"></A></H2>


<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-ProvidinganAspect"></A>Providing an Aspect</H2>

<P>As we have seen in the previous section, there are many annotations  that can be used to specify a service. Another one is the <EM>@AspectService</EM> annotation. This annotation allows to <B>decorate</B> an existing service in  order to add certain &quot;capabilities&quot; to it, like  adding a specific caching mechanism to a storage  service or   implementing logging. Aspects can be plugged to an existing service at   runtime, and can also be removed dynamically. This is transparent, and   the clients using the existing service are not interrupted, they are  just rebound with the aspect service.</P>



<P>As an example, we go back to our SpellChecker application, and we are   now looking at the DictionaryAspect class. This class uses the <EM>@Aspect</EM>Service annotation in order to add some custom words to an English   DictionaryService (with the service property lang=en). The Extra words   to add to the English Dictionary will be configured from ConfigAdmin.   That's why the class also uses a <EM>@ConfigurationDependency</EM> annotation:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@AspectService(ranking = 10, filter = <SPAN class="code-quote">&quot;(lang=en)&quot;</SPAN>)
<SPAN class="code-keyword">public</SPAN> class DictionaryAspect <SPAN class="code-keyword">implements</SPAN> DictionaryService {
&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * This is the service <SPAN class="code-keyword">this</SPAN> aspect is applying to.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> DictionaryService m_originalDictionary;

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * We store all configured words in a thread-safe data structure, because ConfigAdmin may
&nbsp;&nbsp;&nbsp;&nbsp; * invoke our updated method at any time.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">private</SPAN> CopyOnWriteArrayList&lt;<SPAN class="code-object">String</SPAN>&gt; m_words = <SPAN class="code-keyword">new</SPAN> CopyOnWriteArrayList&lt;<SPAN class="code-object">String</SPAN>&gt;();

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Defines a configuration dependency <SPAN class="code-keyword">for</SPAN> retrieving our english custom words (by <SPAN class="code-keyword">default</SPAN>,
&nbsp;&nbsp;&nbsp;&nbsp; * our PID is our full class name).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; @ConfigurationDependency
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">protected</SPAN> void updated(Dictionary&lt;<SPAN class="code-object">String</SPAN>, ?&gt; config) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_words.clear();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-object">String</SPAN>[] words = (<SPAN class="code-object">String</SPAN>[]) config.get(<SPAN class="code-quote">&quot;words&quot;</SPAN>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">String</SPAN> word : words) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_words.add(word);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Checks <SPAN class="code-keyword">if</SPAN> a word is found from our custom word list. <SPAN class="code-keyword">if</SPAN> not, delegate to the decorated
&nbsp;&nbsp;&nbsp;&nbsp; * dictionary.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">boolean</SPAN> checkWord(<SPAN class="code-object">String</SPAN> word) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">if</SPAN> (m_words.contains(word)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">true</SPAN>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class="code-keyword">return</SPAN> m_originalDictionary.checkWord(word);
&nbsp;&nbsp;&nbsp; }
}
</PRE>
</DIV></DIV>
<P>The annotation does the following: because our class implements the   DictionaryService contract, it will instantiate our service each time it   finds another existing DictionaryService matching the filter attribute   we provide in the annotation (filter=&quot;(lang=en)&quot;). And it will inject   the existing service in our m_originalDictionary field, by reflection.   But we can also specify a <EM>field</EM> attribute in the annotation, if  we  want to explicitly inject the existing service in a given class  field. So, any client depending on an English DictionaryService will be  transparently rebound to our aspect Dictionary.</P>

<P>In the Annotation, also notice the <EM>ranking</EM> attribute: It is  the level used to organize the aspect chain ordering (multiple aspects  may be applied on a given service).</P>


<P>The <EM>ConfigurationDependency</EM> is another dependency that we have  not seen before: it is used to configure the extra English words from  ConfigAdmin. This annotation normally requires a pid parameter, which is  a persistent identifier uniquely identifying our component, but by  default, the pid is set to the fully qualified name of our class.</P>

<P>Notice that like the <EM>@FactoryConfigurationAdapterService</EM>, the @<EM>ConfigurationDependency</EM> annotation also supports meta type attributes.</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-QuickTour-Howtorunthesamplecode"></A>How to run the sample code</H2>

<UL>
	<LI>Install the following bundles:</LI>
</UL>


<P>&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.configadmin<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.metatype<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.http.jetty<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.webconsole</P>

<P>&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.dependencymanager<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.dependencymanager.shell<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.dependencymanager.runtime<BR>
&nbsp;&nbsp;&nbsp;&nbsp; org.apache.felix.dependencymanager.samples.annotation</P>


<UL>
	<LI>Start felix</LI>
	<LI>Go to web console: in the Configuration panel, edit the &quot;Dictionary  Services&quot; Configuration. By default, an English  dictionary is displayed. Just&nbsp; click on &quot;save&quot;, then refresh your web  browser (click on refresh): you will see a new dictionary service  instance. At this point, a DictionaryService service will be enabled  (with the service property &quot;lang=en&quot;),&nbsp; and the SpellCheck component  will be injected with it. Then you should see the &quot;spellcheck&quot; command,  when typing&nbsp; &quot;help&quot; on the gogo shell.</LI>
	<LI>Just type &quot;spellcheck hello&quot;, and the command should reply a fantastic message, like &quot;word hello is correct&quot;.</LI>
	<LI>You can also click on the &quot;Aspect Dictionary&quot; button, in order to  decorate the English dictionary with some custom words. By default, the  &quot;aspect&quot; word is pre configured, but you can click on the &quot;+&quot; button in  order to add more words. Then click on Save. At this point, the English  DictionaryService will be decorated with the aspect service. So, now, if  you type &quot;spellcheck aspect&quot;, then the message: &quot;word aspect is  correct&quot; should be displayed.</LI>
</UL>

        <DIV class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
Last modified by pderop on Thu May 12 17:20:57 EDT 2011
        </DIV>
        <DIV class="trademarkFooter">
Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners.
        </DIV>
    </DIV>
  </BODY>
</HTML>

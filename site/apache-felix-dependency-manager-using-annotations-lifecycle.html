
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Felix - Apache Felix Dependency Manager - Using Annotations - Lifecycle</TITLE>
    <LINK rel="stylesheet" href="http://felix.apache.org/site/media.data/site.css" type="text/css" media="all">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY>
    <DIV class="title"><DIV class="logo"><A href="http://felix.apache.org/site/index.html"><IMG border="0" alt="Apache Felix" src="http://felix.apache.org/site/media.data/logo.png"></A></DIV><DIV class="header"><A href="http://www.apache.org/"><IMG border="0" alt="Apache" src="http://felix.apache.org/site/media.data/apache.png"></A></DIV></DIV>
    <DIV class="menu">
<UL>
	<LI><A href="news.html" title="news">news</A></LI>
	<LI><A href="http://www.apache.org/licenses/" class="external-link" rel="nofollow">license</A></LI>
	<LI><A href="http://felix.apache.org/site/downloads.cgi" class="external-link" rel="nofollow">downloads</A></LI>
	<LI><A href="documentation.html" title="documentation">documentation</A></LI>
	<LI><A href="mailinglists.html" title="mailinglists">mailing lists</A></LI>
	<LI><A href="contributing.html" title="Contributing">contributing</A></LI>
	<LI><A href="http://www.apache.org/" class="external-link" rel="nofollow">asf</A></LI>
	<LI><A href="http://www.apache.org/security/" class="external-link" rel="nofollow">security</A></LI>
	<LI><A href="http://www.apache.org/foundation/sponsorship.html" class="external-link" rel="nofollow">sponsorship</A></LI>
	<LI><A href="http://www.apache.org/foundation/thanks.html" class="external-link" rel="nofollow">sponsors</A>
<!-- ApacheCon Ad -->
<IFRAME src="http://www.apache.org/ads/button.html" style="border-width:0; float: left" frameborder="0" scrolling="no" width="135" height="135"></IFRAME>
<P style="height: 100px">
<!-- ApacheCon Ad --></LI>
</UL>
    </DIV>
    <DIV class="main">
<H1><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-AnnotationsLifecycle"></A>Annotations - Lifecycle</H1>




<P>A component has a lifecycle that controls when it is started or stopped. A bundle must be started before the DM Runtime can process its components. When the bundle is started, the DM Runtime then parses a specific <EM>DependencyManager-Component</EM> manifest header, which points to a list of descriptors describing all annotated components. Such descriptors are actually generated at compilation time, and annotation are not reflectively parsed at runtime. Only the descriptor is used to process the components. For each component, the DM Runtime first ensures that all dependencies are satisfied before activating it. Likewise, the component is deactivated when some of the required dependencies are not available anymore or when the bundle is stopped. Unless the bundle is stopped, components may be deactivated and reactivated, depending on the departure and arrival of required dependencies. The manager which is in charge of maintaining the state of components is implemented in the DM Runtime bundle (org.apache.felix.dm.runtime bundle).</P>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-LifecycleCallbacks"></A>Lifecycle Callbacks</H2>

<H3><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-ComponentActivation"></A>Component Activation</H3>



<P>Activating a component consists of the following steps:</P>
<OL>
	<LI>Wait for all required dependencies to be available. When all required dependencies are available:
	<UL>
		<LI>Instantiate the component.</LI>
		<LI>Inject all required dependencies (on class fields using reflection, or by invoking callback methods).</LI>
		<LI>Inject all optional dependencies defined on class fields, <B>possibly with a NullObject</B> if the dependency is not available.</LI>
		<LI>Call the component init method (annotated with <B>@Init</B>). In the  Init method, you are yet allowed to add some additional dependencies  (but using the API). Alternatively, you can also configure some  dependencies dynamically (explained later, in <A href="#ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-DynamicDependencyConfiguration">Dynamic Dependency Configuration</A>).</LI>
	</UL>
	</LI>
	<LI>Wait for extra dependencies optionally configured from the init() method.</LI>
	<LI>If the component is not using the @<B>LifecycleController</B> annotation (detailed in the <A href="#ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-ControllingtheLifecycle">Controlling the Lifecycle</A> section), then:
	<UL>
		<LI>Invoke the component start method (annotated with <B>@Start</B>).</LI>
		<LI>Publish some OSGi services (if the component provides some services).</LI>
		<LI>Start tracking optional dependencies applied on method callbacks (useful for the whiteboard pattern). <B>Notice that NullObject pattern is not applied to optional callback dependencies</B>. In other words, if the dependency is not there, your callback won't be invoked at all. If you need the NullObject pattern, then apply optional dependencies on class fields, not on callback methods.</LI>
	</UL>
	</LI>
	<LI>Else do nothing because&nbsp; the component will trigger itself the startup using the lifecycle controller.</LI>
</OL>


<H3><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-ComponentDeactivation"></A>Component Deactivation</H3>

<P>Deactivating a component consists of the following steps:</P>
<OL>
	<LI>If the bundle is stopped or if some required dependencies are unavailable, or if the component is deactivated by a factorySet, then:
	<UL>
		<LI>Unbind optional dependencies (defined on callback methods). Notice that any optional dependency unavailability does not trigger the component deactivation:&nbsp; the <EM>removed</EM> callbacks are just invoked, if declared in the annotation.</LI>
		<LI>Invoke the stop method (annotated wit <B>@Stop</B>),  and unregister some OSGi services (if the components provides some services).</LI>
		<LI>invoke destroy method (annotated with <B>@Destroy</B>).</LI>
		<LI>invoke <EM>removed</EM> callbacks for required dependencies, if any.</LI>
	</UL>
	</LI>
</OL>


<H3><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-Example"></A>Example</H3>

<P>The following example shows a basic component, which uses the @Start, @Stop, annotation:</P>
<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/**
 * A Component Using lifecyce callbacks
 */
@Component
class X <SPAN class="code-keyword">implements</SPAN> Y {
    @ServiceDependency
    void bindOtherService(OtherService other) {
       <SPAN class="code-comment">// Will be injected before we are started (because it's a required dependency).
</SPAN>    }

    @Start
    void publishing() {
        <SPAN class="code-comment">// All required dependencies are injected: initialize our component.
</SPAN>        <SPAN class="code-comment">// Once we <SPAN class="code-keyword">return</SPAN>, our Y service will be published in the OSGi registry.
</SPAN>    }

    @Stop
    void unpublished() {
       <SPAN class="code-comment">// We are not registered anymore in the OSGi registry.
</SPAN>    }
}
</PRE>
</DIV></DIV>

<H3><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-"></A></H3>


<H3><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-DynamicDependencyConfiguration"></A>Dynamic Dependency Configuration</H3>


<H4><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-Rationale"></A>Rationale</H4>

<P>We have seen that a component may declare some dependencies and is  started when all required dependencies are available. But there are some  cases when you may need to define some dependencies filters  dynamically, possibly from data picked up from other  dependencies (like a configuration dependency for instance).</P>

<P>So, all this is possible using <B>named</B> dependencies: When you assign a name to a dependency; for instance <EM>@ServiceDependency(name=&quot;foo&quot;)</EM>, then this has an impact on how the dependency is handled. Indeed, all named dependencies are calculated <B>after</B> the @Init method returns. So from your @Init method, you can then  configure your named dependencies, using data provided by  already injected dependencies.</P>

<P>To do so, your @Init method is allowed to return a Map containing  the filters and required flags for each named dependencies. For a given  named dependency, the corresponding filter and required flag must be  stored in the Map, using the &quot;<B>filter</B>&quot; and &quot;<B>required</B>&quot; keys, prefixed with the name of the dependency.</P>

<P>For instance, if you define a Dependency like this:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@ServiceDependency(name=<SPAN class="code-quote">&quot;foo&quot;</SPAN>)
FooService fooService;
</PRE>
</DIV></DIV>
<P>Then you can return this map from your @Init method:</P>


<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@Init
Map init() {
    <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> HashMap() {{
        put(<SPAN class="code-quote">&quot;foo.filter&quot;</SPAN>, <SPAN class="code-quote">&quot;(foo=bar)&quot;</SPAN>);
        put(<SPAN class="code-quote">&quot;foo.required&quot;</SPAN>, <SPAN class="code-quote">&quot;<SPAN class="code-keyword">false</SPAN>&quot;</SPAN>);
    }};
}
</PRE>
</DIV></DIV>
<P>So, after the init method returns, the map will be used to configure  the dependency named &quot;foo&quot;, which will then be evaluated. And once the  dependency is available, then your @Start callback will be invoked.</P>

<H4><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-Usageexample%3A"></A>Usage example:</H4>

<P>This is an example of a component X whose dependency &quot;foo&quot; filter is  configured from ConfigAdmin. First, we defined a ConfigurationDependency  in order to get injected with our configuration. Next, we define a  dependency on the <EM>FooService</EM>, but this time, we declare the annotation  like this: <EM>@ServiceDependency(</EM><B><EM>name=&quot;foo&quot;</EM></B><EM>)</EM>. As explained  above, The  ConfigurationDependency will be injected <B>before</B> the @Init method, and  the named dependency (&quot;foo&quot;) will be calculated <B>after</B> the @Init method  returns. So, from our Init method, we just return a map which contains  the filter and required flag for the &quot;foo&quot; dependency, and we actually  use the configuration which has already been injected:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/**
 * A component whose FooService dependency filter is configured from ConfigAdmin
 */
@Component
class X {
    <SPAN class="code-keyword">private</SPAN> Dictionary m_config;

    /**
     * Initialize our component from config ... and store the config <SPAN class="code-keyword">for</SPAN> later usage (from our init method)
     */
    @ConfigurationDependency(pid=<SPAN class="code-quote">&quot;MyPid&quot;</SPAN>)
    void configure(Dictionary conf) {
         m_config = config;
    }

    /**
     * All unnamed dependencies are injected: we can now configure other named
     * dependencies, using the already injected configuration.
     * The returned Map will be used to configure our <SPAN class="code-quote">&quot;foo&quot;</SPAN> Dependency (see below)
     */
    @Init
    Map init() {
        <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> HashMap() {{
            put(<SPAN class="code-quote">&quot;foo.filter&quot;</SPAN>, m_config.get(<SPAN class="code-quote">&quot;filter&quot;</SPAN>));
            put(<SPAN class="code-quote">&quot;foo.required&quot;</SPAN>, m_config.get(<SPAN class="code-quote">&quot;required&quot;</SPAN>));
        }};
    }

    /**
     * This named dependency filter/required flag will be configured by our init method (see above).
     */
    @ServiceDependency(name=<SPAN class="code-quote">&quot;foo&quot;</SPAN>)
    FooService fooService;

    /**
     * All dependencies are injected and our service is now ready to be published.
     */
    @Start
    void start() {
    }
}
</PRE>
</DIV></DIV>



<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-"></A></H2>


<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-ControllingtheLifecycle"></A>Controlling the Lifecycle</H2>

<P>As explained in the <EM>Component Activation</EM> section, a  component which provides a service is automatically registered into the  OSGi registry, after the @Start method returns. But it is sometimes  required to control when the service is really started/published or  unpublished/stopped.</P>

<P>This can be done using the @LifecycleController annotation. This  annotation injects a Runnable object that can be invoked once you want  to trigger your service startup and publication.</P>

<P>For instance, imagine that your component publishes an OSGi service,  but before, it needs to register into a DHT (Distributed Hash Table),  whose API is asynchronous: that is: the DHT API will callback you once  you are inserted into a node in the DHT. In this case, what you would  like to do is to publish your OSGi service, but only after you are  inserted into the DHT (when the DHT callbacks you) ... Such a case  is supported using the @LifecyceController annotation, which gives you  full control of when your component is <B>started/published</B> and <B>unpublished/stopped</B>.</P>

<P>Let's illustrate this use case with a concrete example: First here is the DHT asynchronous API:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/**
 * This is an element which can be inserted into the distributed hash table.
 */
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> DHTElement {
   void inserted(); <SPAN class="code-comment">// callback used to notify that the element is inserted into the DHT
</SPAN>}

/**
 * This is the DHTService, which registers a DHTElement asynchronously.
 */
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> DHTService {
   void insert(DHTElement element); <SPAN class="code-comment">// will callback element.inserted() later, once registered into the DHT.
</SPAN>}
</PRE>
</DIV></DIV>
<P>Next, here is our service, which uses the @LifecycleController in  order to take control of when the service is published into the OSGi  registry:</P>


<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@Component(provides={MyService.class})
<SPAN class="code-keyword">public</SPAN> class MyServiceImpl <SPAN class="code-keyword">implements</SPAN> MyService, DHTElement {
    @ServiceDependency
    DHTService dht;

    @LifecycleController
    <SPAN class="code-object">Runnable</SPAN> trigger; <SPAN class="code-comment">// will fire component startup, once invoked.
</SPAN>
    @Init
    void init() {
        dht.insert(<SPAN class="code-keyword">this</SPAN>); <SPAN class="code-comment">// asynchronous, will callback us in our inserted method once registered into the DHT
</SPAN>    }

    <SPAN class="code-keyword">public</SPAN> void inserted() {
        <SPAN class="code-comment">// We are inserted into the DHT: we can now trigger our component startup.
</SPAN>        <SPAN class="code-comment">// We just invoke the runnable injected by our @LifecycleController annotation, which will trigger our
</SPAN>        <SPAN class="code-comment">// service publication (we'll be called in our @Start method before)
</SPAN>        trigger.run();
    }

    @Start
    void start() {
        <SPAN class="code-comment">// method called only once we invoke our trigger <SPAN class="code-object">Runnable</SPAN> (see inserted method).
</SPAN>        <SPAN class="code-comment">// Our Service will be published once <SPAN class="code-keyword">this</SPAN> method returns.
</SPAN>    }
}
</PRE>
</DIV></DIV>

<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-"></A></H2>


<H2><A name="ApacheFelixDependencyManager-UsingAnnotations-Lifecycle-DynamicServiceProperties"></A>Dynamic Service Properties</H2>

<P>When a component provides an OSGi Service, the service properties are calculated as the following:</P>
<UL>
	<LI>Any properties specified in the @Component annotation are used to provide the OSGi Service</LI>
	<LI>Any properties provided by a FactorySet are also inserted in the published service</LI>
	<LI>Any Dependency whose <EM>propagate</EM> attribute is set to true will also insert its properties to the published service</LI>
</UL>


<P>But when the component needs to specify some service properties dynamically (not statically from the annotation), then it may do so by just returning a Map from the @Start callback. For instance:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
@Component(properties={@Property(name=<SPAN class="code-quote">&quot;foo&quot;</SPAN>, value=<SPAN class="code-quote">&quot;bar&quot;</SPAN>)})
<SPAN class="code-keyword">public</SPAN> class MyServiceImpl <SPAN class="code-keyword">implements</SPAN> MyService {
    @ConfigurationDependency(pid=<SPAN class="code-quote">&quot;MyPid&quot;</SPAN>, propagate=<SPAN class="code-keyword">true</SPAN>)
    void updated(Dictionary conf) {
       <SPAN class="code-comment">// <SPAN class="code-quote">&quot;conf&quot;</SPAN> contains foo2=bar2, <SPAN class="code-keyword">for</SPAN> example, and since we have set the <SPAN class="code-quote">&quot;propagate&quot;</SPAN> attribute to <SPAN class="code-keyword">true</SPAN>, then
</SPAN>       <SPAN class="code-comment">// the property will be propagated to our published service ...
</SPAN>    }

    @Start
    Map start() {
        <SPAN class="code-comment">// Return some extra properties to be inserted along with our published properties. This map takes
</SPAN>        <SPAN class="code-comment">// precedence, and may override some properties specified in our @Component annotation, or some properties
</SPAN>        <SPAN class="code-comment">// propagated from our @ConfigurationDependency dependency ...
</SPAN>        <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> HashMap() {{ put(<SPAN class="code-quote">&quot;foo3&quot;</SPAN>, <SPAN class="code-quote">&quot;bar3&quot;</SPAN>); }};
    }
}
</PRE>
</DIV></DIV>
<P>Here, the service MyService will be published into the OSGi registry along with the following service properties:</P>
<UL>
	<LI>foo=bar (specified in our @Component annotation)</LI>
	<LI>foo2=bar2 (propagated by our ConfigurationDependency dependency)</LI>
	<LI>foo3=bar3 (specified dynamically in the map returned from our start method)</LI>
</UL>


<P>Notice that properties returned by the Map take precedence over other properties, and may override some of them.</P>
        <DIV class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
Last modified by pderop on Fri Jun 10 12:14:01 EDT 2011
        </DIV>
        <DIV class="trademarkFooter">
Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners.
        </DIV>
    </DIV>
  </BODY>
</HTML>

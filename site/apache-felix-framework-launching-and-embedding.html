
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Felix - Apache Felix Framework Launching and Embedding</TITLE>
    <LINK rel="stylesheet" href="http://felix.apache.org/site/media.data/site.css" type="text/css" media="all">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY>
    <DIV class="title"><DIV class="logo"><A href="http://felix.apache.org/site/index.html"><IMG border="0" alt="Apache Felix" src="http://felix.apache.org/site/media.data/logo.png"></A></DIV><DIV class="header"><A href="http://www.apache.org/"><IMG border="0" alt="Apache" src="http://felix.apache.org/site/media.data/apache.png"></A></DIV></DIV>
    <DIV class="menu">
<UL>
	<LI><A href="news.html" title="news">news</A></LI>
	<LI><A href="http://www.apache.org/licenses/" class="external-link" rel="nofollow">license</A></LI>
	<LI><A href="http://felix.apache.org/site/downloads.cgi" class="external-link" rel="nofollow">downloads</A></LI>
	<LI><A href="documentation.html" title="documentation">documentation</A></LI>
	<LI><A href="mailinglists.html" title="mailinglists">mailing lists</A></LI>
	<LI><A href="contributing.html" title="Contributing">contributing</A></LI>
	<LI><A href="http://www.apache.org/" class="external-link" rel="nofollow">asf</A></LI>
	<LI><A href="http://www.apache.org/security/" class="external-link" rel="nofollow">security</A></LI>
	<LI><A href="http://www.apache.org/foundation/sponsorship.html" class="external-link" rel="nofollow">sponsorship</A></LI>
	<LI><A href="http://www.apache.org/foundation/thanks.html" class="external-link" rel="nofollow">sponsors</A>
<!-- ApacheCon Ad -->
<IFRAME src="http://www.apache.org/ads/button.html" style="border-width:0; float: left" frameborder="0" scrolling="no" width="135" height="135"></IFRAME>
<P style="height: 100px">
<!-- ApacheCon Ad --></LI>
</UL>
    </DIV>
    <DIV class="main">
<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-ApacheFelixFrameworkLaunchingandEmbedding"></A>Apache Felix Framework Launching and Embedding</H1>

<P><EM>[This document describes framework launching introduced in Felix Framework 2.0.0 and continuing with the latest releases; it is incompatible with older versions of the Felix framework.]</EM></P>

<UL>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-introduction">Introduction</A></LI>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-overview">OSGi Launching and Embedding API Overview</A>
	<UL>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-creatingandconfiguring">Creating and Configuring the Framework Instance</A></LI>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-startinginstance">Starting the Framework Instance</A></LI>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-stoppinginstance">Stopping the Framework Instance</A></LI>
	</UL>
	</LI>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-launching">Launching Felix</A>
	<UL>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-standardlauncher">Standard Felix Launcher</A></LI>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-customlauncher">Custom Felix Launcher</A></LI>
	</UL>
	</LI>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-embedding">Embedding Felix</A>
	<UL>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction">Host/Felix Interaction</A></LI>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-hostservices">Providing Host Application Services</A></LI>
		<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-hostserviceusage">Using Services Provided by Bundles</A>
		<UL>
			<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-servicereflection">Using Bundle Services via Reflection</A></LI>
			<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-serviceother">Other Approaches</A></LI>
		</UL>
		</LI>
	</UL>
	</LI>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-caveat">Caveat</A></LI>
	<LI><A href="#ApacheFelixFrameworkLaunchingandEmbedding-feedback">Feedback</A></LI>
</UL>


<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-introduction"></A></P>

<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-Introduction"></A>Introduction</H1>

<P>The Apache Felix Framework is intended to be easily launchable and embeddable. For example, the Felix framework implementation avoids the use of system properties for configuration, since these are globals and can cause interference if multiple framework instances are created in the same VM. The framework also tries to multiplex singleton facilities, like the URL stream handler factory. The goal is to make it possible to use the framework in a variety of scenarios; however, this is still just a goal. In other words, this is a work in progress and if any issues arise, it would be greatly appreciated if they are brought to the attention of the Felix community. The next section provides an overview of the standard OSGi launching and embedding API for frameworks, while the remainder of the document is divided into two sections, one focusing on how to launch Felix and one focusing on how to embed Felix into a host application.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-overview"></A></P>

<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-OSGiLaunchingandEmbeddingAPIOverview"></A>OSGi Launching and Embedding API Overview</H1>

<P>The Felix framework is implemented by the <TT>org.apache.felix.framework.Felix</TT> class or just <TT>Felix</TT> for short. As part of the R4.2 OSGi specification, the launching and embedding API of the OSGi framework has been standardized. The approach is to have the framework implement the <TT>org.osgi.framework.launch.Framework</TT> interface, which extends the <TT>org.osgi.framework.Bundle</TT> interface. These interfaces provide the necessary means to launch and manage framework instances. The <TT>Bundle</TT> interface is defined as:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> Bundle
{
    BundleContext getBundleContext();
    <SPAN class="code-object">long</SPAN> getBundleId();
    URL getEntry(<SPAN class="code-object">String</SPAN> name);
    Enumeration getEntryPaths(<SPAN class="code-object">String</SPAN> path);
    Enumeration findEntries(<SPAN class="code-object">String</SPAN> path, <SPAN class="code-object">String</SPAN> filePattern, <SPAN class="code-object">boolean</SPAN> recurse);
    Dictionary getHeaders();
    Dictionary getHeaders(<SPAN class="code-object">String</SPAN> locale);
    <SPAN class="code-object">long</SPAN> getLastModified();
    <SPAN class="code-object">String</SPAN> getLocation();
    URL getResource(<SPAN class="code-object">String</SPAN> name);
    Enumeration getResources(<SPAN class="code-object">String</SPAN> name) <SPAN class="code-keyword">throws</SPAN> IOException;
    ServiceReference[] getRegisteredServices();
    ServiceReference[] getServicesInUse();
    <SPAN class="code-object">int</SPAN> getState();
    <SPAN class="code-object">String</SPAN> getSymbolicName();
    Version getVersion();
    <SPAN class="code-object">boolean</SPAN> hasPermission(<SPAN class="code-object">Object</SPAN> obj);
    <SPAN class="code-object">Class</SPAN> loadClass(<SPAN class="code-object">String</SPAN> name) <SPAN class="code-keyword">throws</SPAN> ClassNotFoundException;
    void start() <SPAN class="code-keyword">throws</SPAN> BundleException;
    void stop() <SPAN class="code-keyword">throws</SPAN> BundleException;
    void uninstall() <SPAN class="code-keyword">throws</SPAN> BundleException;
    void update() <SPAN class="code-keyword">throws</SPAN> BundleException;
    void update(InputStream is) <SPAN class="code-keyword">throws</SPAN> BundleException;
}
</PRE>
</DIV></DIV>

<P>The <TT>Framework</TT> interface is defined as:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> Framework <SPAN class="code-keyword">extends</SPAN> Bundle
{
    void init();
    FrameworkEvent waitForStop(<SPAN class="code-object">long</SPAN> timeout);
}
</PRE>
</DIV></DIV>

<P>To actually construct a framework instance, the R4.2 specification defines the <TT>FrameworkFactory</TT> interface:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> FrameworkFactory
{
    Framework newFramework(Map config);
}
</PRE>
</DIV></DIV>

<P>The framework factory can be used to create configured framework instances. It is obtained following the standard <TT>META-INF/services</TT> approach.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-creatingandconfiguring"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-CreatingandConfiguringtheFrameworkInstance"></A>Creating and Configuring the Framework Instance</H2>

<P>You use the framework factory to construct and configure a framework instance (or by directly instantiating the Felix class). The configuration map may contain any of the framework configuration properties listed in the <A href="apache-felix-framework-configuration-properties.html" title="Apache Felix Framework Configuration Properties">Apache Felix Framework Configuration Properties</A> document, not the launcher configuration properties. The configuration map is copied and the keys are treated as case insensitive. You are not able to change the framework's configuration after construction. If you need a different configuration, you must create a new framework instance.</P>

<DIV class="panelMacro"><TABLE class="warningMacro"><COLGROUP><COL width="24"><COL></COLGROUP><TR><TD valign="top"><IMG src="https://cwiki.apache.org/confluence/images/icons/emoticons/forbidden.gif" width="16" height="16" align="absmiddle" alt="" border="0"></TD><TD><B>WARNING</B><BR>Felix configuration properties have change considerably starting from <TT>1.4.0</TT>; if you are upgrading from an earlier version, the <A href="apache-felix-framework-configuration-properties.html#ApacheFelixFrameworkConfigurationProperties-migrating">configuration property document</A> describes the configuration property changes.</TD></TR></TABLE></DIV>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-startinginstance"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-StartingtheFrameworkInstance"></A>Starting the Framework Instance</H2>

<P>The <TT>start()</TT> method is used to start the framework instance. If the <TT>init()</TT> method was not invoked prior to calling <TT>start()</TT>, then it is invoked by <TT>start()</TT>. The two methods result in two different framework state transitions:</P>

<UL>
	<LI><TT>init()</TT> results in the framework instance in the <TT>Bundle.STARTING</TT> state.</LI>
	<LI><TT>start()</TT> results in the framework instance in the <TT>Bundle.ACTIVE</TT> state.</LI>
</UL>


<P>The <TT>init()</TT> method is necessary since the framework does not have a <TT>BundleContext</TT> when it is first created, so a transition to the <TT>Bundle.STARTING</TT> state is required to acquire its context (via <TT>Bundle.getBundleContext()</TT>) for performing various tasks, such as installing bundles. Note that the Felix framework also provides the <TT>felix.systembundle.activators</TT> property that serves a similar purpose, but is not standard. After the <TT>init()</TT> method completes, the follow actions have been performed:</P>

<UL>
	<LI>Event handling is enabled.</LI>
	<LI>The security manager is installed if it is enabled.</LI>
	<LI>The framework is set to start level 0.</LI>
	<LI>All bundles in the bundle caches are reified and their state is set to <TT>Bundle.INSTALLED</TT>.</LI>
	<LI>The framework gets a valid <TT>BundleContext</TT>.</LI>
	<LI>All framework-provided services are made available (e.g., PackageAdmin, StartLevel, etc.).</LI>
	<LI>The framework enters the <TT>Bundle.STARTING</TT> state.</LI>
</UL>


<P>A call to <TT>start()</TT> is necessary to start the framework instance, if the <TT>init()</TT> method is invoked manually. Invoking <TT>init()</TT> or <TT>start()</TT> on an already started framework as no effect.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-stoppinginstance"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-StoppingtheFrameworkInstance"></A>Stopping the Framework Instance</H2>

<P>To stop the framework instance, invoke the <TT>stop()</TT> method, which will asynchronously stop the framework. To know when the framework has finished its shutdown sequence, use the <TT>waitForStop()</TT> method to wait until it is complete. A stopped framework will be in the <TT>Bundle.RESOLVED</TT> state. It is possible to restart the framework, using the normal combination of <TT>init()</TT>/<TT>start()</TT> methods as previously described.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-launching"></A></P>

<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-LaunchingaFramework"></A>Launching a Framework</H1>

<P>Launching a framework is fairly simple and involves only four steps:</P>

<OL>
	<LI>Define some configuration properties.</LI>
	<LI>Obtain framework factory.</LI>
	<LI>Use factory to create framework with the configuration properties.</LI>
	<LI>Invoke the <TT>Framework.start()</TT> method.</LI>
</OL>


<P>In reality, the first step is optional, since all properties will have reasonable defaults, but if you are creating a launcher you will generally want to more than that, such as automatically installing and starting bundles when you start the framework instance. The default Felix launcher defines reusable functionality to automatically install and/or start bundles upon framework startup; see the <A href="apache-felix-framework-usage-documentation.html#ApacheFelixFrameworkUsageDocumentation-configuringfelix">usage document</A> for more information on configuring the Felix framework and on the various configuration properties.</P>

<P>The remainder of this section describes how the standard Felix launcher works as well as how to create a custom launcher.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-standardlauncher"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-StandardFelixFrameworkLauncher"></A>Standard Felix Framework Launcher</H2>

<P>The standard Felix framework launcher is very simple and is not intended to solve every possible requirement; it is intended to work for most standard situations. Most special launching requirements should be resolved by creating a custom launcher. This section describes how the standard launcher works. The following code represents the complete <TT>main()</TT> method of the standard launcher, each numbered comment will be described in more detail below:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">static</SPAN> void main(<SPAN class="code-object">String</SPAN>[] args) <SPAN class="code-keyword">throws</SPAN> Exception
{
    <SPAN class="code-comment">// (1) Check <SPAN class="code-keyword">for</SPAN> command line arguments and verify usage.
</SPAN>    <SPAN class="code-object">String</SPAN> bundleDir = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-object">String</SPAN> cacheDir = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-object">boolean</SPAN> expectBundleDir = <SPAN class="code-keyword">false</SPAN>;
    <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">int</SPAN> i = 0; i &lt; args.length; i++)
    {
        <SPAN class="code-keyword">if</SPAN> (args[i].equals(BUNDLE_DIR_SWITCH))
        {
            expectBundleDir = <SPAN class="code-keyword">true</SPAN>;
        }
        <SPAN class="code-keyword">else</SPAN> <SPAN class="code-keyword">if</SPAN> (expectBundleDir)
        {
            bundleDir = args[i];
            expectBundleDir = <SPAN class="code-keyword">false</SPAN>;
        }
        <SPAN class="code-keyword">else</SPAN>
        {
            cacheDir = args[i];
        }
    }

    <SPAN class="code-keyword">if</SPAN> ((args.length &gt; 3) || (expectBundleDir &amp;&amp; bundleDir == <SPAN class="code-keyword">null</SPAN>))
    {
        <SPAN class="code-object">System</SPAN>.out.println(<SPAN class="code-quote">&quot;Usage: [-b &lt;bundle-deploy-dir&gt;] [&lt;bundle-cache-dir&gt;]&quot;</SPAN>);
        <SPAN class="code-object">System</SPAN>.exit(0);
    }

    <SPAN class="code-comment">// (2) Load system properties.
</SPAN>    Main.loadSystemProperties();

    <SPAN class="code-comment">// (3) Read configuration properties.
</SPAN>    Properties configProps = Main.loadConfigProperties();
    <SPAN class="code-keyword">if</SPAN> (configProps == <SPAN class="code-keyword">null</SPAN>)
    {
        <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;No &quot;</SPAN> + CONFIG_PROPERTIES_FILE_VALUE + <SPAN class="code-quote">&quot; found.&quot;</SPAN>);
        configProps = <SPAN class="code-keyword">new</SPAN> Properties();
    }

    <SPAN class="code-comment">// (4) Copy framework properties from the system properties.
</SPAN>    Main.copySystemProperties(configProps);
        
    <SPAN class="code-comment">// (5) Use the specified auto-deploy directory over <SPAN class="code-keyword">default</SPAN>.
</SPAN>    <SPAN class="code-keyword">if</SPAN> (bundleDir != <SPAN class="code-keyword">null</SPAN>)
    {
        configProps.setProperty(AutoProcessor.AUTO_DEPLOY_DIR_PROPERY, bundleDir);
    }

    <SPAN class="code-comment">// (6) Use the specified bundle cache directory over <SPAN class="code-keyword">default</SPAN>.
</SPAN>    <SPAN class="code-keyword">if</SPAN> (cacheDir != <SPAN class="code-keyword">null</SPAN>)
    {
        configProps.setProperty(Constants.FRAMEWORK_STORAGE, cacheDir);
    }

    <SPAN class="code-comment">// (7) Add a shutdown hook to clean stop the framework.
</SPAN>    <SPAN class="code-object">String</SPAN> enableHook = configProps.getProperty(SHUTDOWN_HOOK_PROP);
    <SPAN class="code-keyword">if</SPAN> ((enableHook == <SPAN class="code-keyword">null</SPAN>) || !enableHook.equalsIgnoreCase(<SPAN class="code-quote">&quot;<SPAN class="code-keyword">false</SPAN>&quot;</SPAN>))
    {
        <SPAN class="code-object">Runtime</SPAN>.getRuntime().addShutdownHook(<SPAN class="code-keyword">new</SPAN> <SPAN class="code-object">Thread</SPAN>(<SPAN class="code-quote">&quot;Felix Shutdown Hook&quot;</SPAN>) {
            <SPAN class="code-keyword">public</SPAN> void run()
            {
                <SPAN class="code-keyword">try</SPAN>
                {
                    <SPAN class="code-keyword">if</SPAN> (m_fwk != <SPAN class="code-keyword">null</SPAN>)
                    {
                        m_fwk.stop();
                        m_fwk.waitForStop(0);
                    }
                }
                <SPAN class="code-keyword">catch</SPAN> (Exception ex)
                {
                    <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Error stopping framework: &quot;</SPAN> + ex);
                }
            }
        });
    }

    <SPAN class="code-keyword">try</SPAN>
    {
        <SPAN class="code-comment">// (8) Create an instance and initialize the framework.
</SPAN>        FrameworkFactory factory = getFrameworkFactory();
        m_fwk = factory.newFramework(configProps);
        m_fwk.init();
        <SPAN class="code-comment">// (9) Use the system bundle context to process the auto-deploy
</SPAN>        <SPAN class="code-comment">// and auto-install/auto-start properties.
</SPAN>        AutoProcessor.process(configProps, m_fwk.getBundleContext());
        <SPAN class="code-comment">// (10) Start the framework.
</SPAN>        m_fwk.start();
        <SPAN class="code-comment">// (11) Wait <SPAN class="code-keyword">for</SPAN> framework to stop to exit the VM.
</SPAN>        m_fwk.waitForStop(0);
        <SPAN class="code-object">System</SPAN>.exit(0);
    }
    <SPAN class="code-keyword">catch</SPAN> (Exception ex)
    {
        <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Could not create framework: &quot;</SPAN> + ex);
        ex.printStackTrace();
        <SPAN class="code-object">System</SPAN>.exit(0);
    }
}
</PRE>
</DIV></DIV>

<P>The general steps of the standard launcher are quite straightforward:</P>

<OL>
	<LI>The launcher supports setting the auto-deploy directory (with the <TT>-b</TT> switch) and setting the bundle cache path with a single argument, so check for this and issue a usage message it there are more than one arguments.</LI>
	<LI>Load any system properties specified in the <TT>system.properties</TT> file; this file is typically located in the <TT>conf/</TT> directory of the Felix installation directory, but it can be specified directly using the <TT>felix.system.properties</TT> system property. This file is not needed to launch Felix and is provided merely for convenience when system properties must be specified. The file is a standard Java properties file, but it also supports property substitution using <TT>${&lt;property-name</TT>} syntax. Property substitution can be nested; only system properties will be used for substitution.</LI>
	<LI>Load any configuration properties specified in the <TT>config.properties</TT> file; this file is typically located in the <TT>conf/</TT> directory of the Felix installation directory, but it can be specified directly using the <TT>felix.config.properties</TT> system property. This file is used to configure the framework instance created by the launcher. The file is a standard Java properties file, but it also supports property substitution using &quot;<TT>${&lt;property-name&gt;</TT>}&quot; syntax. Property substitution can be nested; configuration and system properties will be used for substitution with configuration properties having precedence.</LI>
	<LI>For convenience, any configuration properties that are set as system properties are copied into the set of configuration properties. This provide an easy way to add to or override configuration properties specified in the <TT>config.properties</TT> file, since the Felix instance will never look at system properties for configuration.</LI>
	<LI>If the <TT>-b</TT> switch was used to specify an auto-deploy directory, then use that to set the value of <TT>felix.auto.deploy.dir</TT>.</LI>
	<LI>If a single command-line argument is specified, then use that to set the value of <TT>org.osgi.framework.storage</TT>; relative paths are relative to the current directory unless the <TT>felix.cache.rootdir</TT> property is set.</LI>
	<LI>Add a shutdown hook to cleanly stop the framework, unless the hook is disabled.</LI>
	<LI>Create a framework instance using the <TT>FrameworkFactory</TT> passing in the configuration properties, then initialize the factory instance; see the <A href="#ApacheFelixFrameworkLaunchingandEmbedding-customlauncher">custom launcher example</A> below to see how the META-INF/services <TT>FrameworkFactory</TT> is obtained.</LI>
	<LI>Use <TT>org.apache.felix.main.AutoProcessor</TT>, which will automatically deploy any bundles in the auto-deploy directory as well as bundles specified in the <TT>felix.auto.install</TT> and <TT>felix.auto.start</TT> configuration properties during framework startup to automatically install and/or start bundles; see the usage document for more information <A href="apache-felix-framework-usage-documentation.html#ApacheFelixFrameworkUsageDocumentation-configuringframework">configuration properties</A> and <A href="apache-felix-framework-usage-documentation.html#ApacheFelixFrameworkUsageDocumentation-autodeploy">bundle auto-deploy</A>.</LI>
	<LI>Invoke <TT>waitForStop()</TT> to wait for the framework to stop to force the VM to exit; this is necessary because the framework never calls <TT>System.exit()</TT> and some libraries (e.g., Swing) create threads that will not allow the VM to exit.</LI>
</OL>


<P>The framework is not active until the <TT>start()</TT> method is called. If no shell bundles are installed and started or if there is difficulty locating the shell bundles specified in the auto-start property, then it will appear as if the framework is hung, but it is actually running without any way to interact with it since the shell bundles provide the only means of interaction.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-customlauncher"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-CustomFrameworkLauncher"></A>Custom Framework Launcher</H2>

<P>This section creates a bare-bones launcher to demonstrate the minimum requirements for creating an interactive launcher for the Felix framework. This example uses the standard Gogo shell bundles for interactivity, but any other bundles could be used instead. This example launcher project has the following directory structure:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>launcher/
   lib/
      org.apache.felix.main-3.0.0.jar
   bundle/
      org.apache.felix.gogo.command-0.6.0.jar
      org.apache.felix.gogo.runtime-0.6.0.jar
      org.apache.felix.gogo.shell-0.6.0.jar
   src/
      example/
         Main.java
</PRE>
</DIV></DIV>

<P>The <TT>lib/</TT> directory contains Felix' main JAR file, which also contains the OSGi core interfaces. The main JAR file is used so that we can reuse the default launcher's auto-install/auto-start configuration property handling; if these capabilities are not needed, then it would be possible to use the framework JAR file instead of the main JAR file. The <TT>bundle/</TT> directory contains the shell service and textual shell interface bundles that will be used for interacting with the framework instance. Note: If you do not launch the framework with interactive bundles, it will appear as if the framework instance is hung, but it is actually just sitting there waiting for someone to tell it to do something. The <TT>src/example/</TT> directory contains the following <TT>Main.java</TT> file, which is a very simplistic framework launcher.</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> example;

<SPAN class="code-keyword">import</SPAN> java.io.*;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.launch.*;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.main.AutoProcessor;

<SPAN class="code-keyword">public</SPAN> class Main
{
    <SPAN class="code-keyword">private</SPAN> <SPAN class="code-keyword">static</SPAN> Framework m_fwk = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">static</SPAN> void main(<SPAN class="code-object">String</SPAN>[] argv) <SPAN class="code-keyword">throws</SPAN> Exception
    {
        <SPAN class="code-comment">// Print welcome banner.
</SPAN>        <SPAN class="code-object">System</SPAN>.out.println(<SPAN class="code-quote">&quot;\nWelcome to My Launcher&quot;</SPAN>);
        <SPAN class="code-object">System</SPAN>.out.println(<SPAN class="code-quote">&quot;======================\n&quot;</SPAN>);

        <SPAN class="code-keyword">try</SPAN>
        {
            m_fwk = getFrameworkFactory().newFramework(<SPAN class="code-keyword">null</SPAN>);
            m_fwk.init();
            AutoProcessor.process(<SPAN class="code-keyword">null</SPAN>, m_fwk.getBundleContext());
            m_fwk.start();
            m_fwk.waitForStop(0);
            <SPAN class="code-object">System</SPAN>.exit(0);
        }
        <SPAN class="code-keyword">catch</SPAN> (Exception ex)
        {
            <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Could not create framework: &quot;</SPAN> + ex);
            ex.printStackTrace();
            <SPAN class="code-object">System</SPAN>.exit(-1);
        }
    }

    <SPAN class="code-keyword">private</SPAN> <SPAN class="code-keyword">static</SPAN> FrameworkFactory getFrameworkFactory() <SPAN class="code-keyword">throws</SPAN> Exception
    {
        java.net.URL url = Main.class.getClassLoader().getResource(
            <SPAN class="code-quote">&quot;META-INF/services/org.osgi.framework.launch.FrameworkFactory&quot;</SPAN>);
        <SPAN class="code-keyword">if</SPAN> (url != <SPAN class="code-keyword">null</SPAN>)
        {
            BufferedReader br = <SPAN class="code-keyword">new</SPAN> BufferedReader(<SPAN class="code-keyword">new</SPAN> InputStreamReader(url.openStream()));
            <SPAN class="code-keyword">try</SPAN>
            {
                <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">String</SPAN> s = br.readLine(); s != <SPAN class="code-keyword">null</SPAN>; s = br.readLine())
                {
                    s = s.trim();
                    <SPAN class="code-comment">// Try to load first non-empty, non-commented line.
</SPAN>                    <SPAN class="code-keyword">if</SPAN> ((s.length() &gt; 0) &amp;&amp; (s.charAt(0) != '#'))
                    {
                        <SPAN class="code-keyword">return</SPAN> (FrameworkFactory) <SPAN class="code-object">Class</SPAN>.forName(s).newInstance();
                    }
                }
            }
            <SPAN class="code-keyword">finally</SPAN>
            {
                <SPAN class="code-keyword">if</SPAN> (br != <SPAN class="code-keyword">null</SPAN>) br.close();
            }
        }

        <SPAN class="code-keyword">throw</SPAN> <SPAN class="code-keyword">new</SPAN> Exception(<SPAN class="code-quote">&quot;Could not find framework factory.&quot;</SPAN>);
    }
}
</PRE>
</DIV></DIV>

<P>This launcher relies on the default behavior of <TT>AutoProcessor</TT> to automatically deploy the shell bundles. This simple, generic launcher provides a good starting point if the default Felix launcher is not sufficient. Since very few configuration properties are specified, the default values are used. For the bundle auto-deploy directory, &quot;<TT>bundle</TT>&quot; in the current directory is used, while for the framework bundle cache, &quot;<TT>felix-cache</TT>&quot; in the current directory is used.</P>

<P>By breaking down the above source code into small chunks, it is quite easy to see what is going on.</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
            m_fwk = getFrameworkFactory().newFramework(<SPAN class="code-keyword">null</SPAN>);
            m_fwk.init()
</PRE>
</DIV></DIV>

<P>These steps get a the framework factory service and use it to create a framework instance with a default configuration. Once the framework instance is created, it is initialized with <TT>init()</TT>.</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
            AutoProcessor.process(<SPAN class="code-keyword">null</SPAN>, m_fwk.getBundleContext());
</PRE>
</DIV></DIV>

<P>The <TT>AutorProcessor</TT> will automatically deploy bundles in the auto-deploy directory and any referenced from the auto-install/start properties. Since we are using an empty configuration, the auto-deploy directory is the <TT>bundle</TT> directory in the current directory and there are no auto properties. Therefore, in this case, the shell bundles will be installed.</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
            m_fwk.start();
            m_fwk.waitForStop(0);
            <SPAN class="code-object">System</SPAN>.exit(0);
</PRE>
</DIV></DIV>

<P>These final steps start the framework and cause the launching application thread to wait for the framework to stop and when it does the launching thread calls <TT>System.exit()</TT> to make sure the VM actually exits.</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
    <SPAN class="code-keyword">private</SPAN> <SPAN class="code-keyword">static</SPAN> FrameworkFactory getFrameworkFactory() <SPAN class="code-keyword">throws</SPAN> Exception
    {
        ...
    }
</PRE>
</DIV></DIV>

<P>This method retrieves the framework factory service by doing a META-INF/services resource lookup, which it can use to obtain the concrete class name for the factory. If you are using Java 6, then you can use the <TT>ServiceLoader</TT> API in the JRE to further simplify the factory service lookup.</P>

<P>The following command compiles the launcher when run from the root directory of the launcher project:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>javac -d . -classpath lib/org.apache.felix.main-3.0.0.jar src/example/Main.java
</PRE>
</DIV></DIV>

<P>After executing this command, an <TT>example/</TT> directory is created in the current directory, which contains the generated class file. The following command executes the simple launcher when run from the root directory of the launcher project:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>java -cp .:lib/org.apache.felix.main-3.0.0.jar example.Main
</PRE>
</DIV></DIV>

<P>After executing this command, a &quot;<TT>felix-cache/</TT>&quot; directory is created that contains the cached bundles, which were installed from the <TT>bundle/</TT> directory.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-embedding"></A></P>

<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-EmbeddingtheFelixFramework"></A>Embedding the Felix Framework</H1>

<P>Embedding the Felix framework into a host application is a simple way to provide a sophisticated extensibility mechanism (i.e., a plugin system) to the host application. Embedding the Felix framework is very similar to launching it as described above, the main difference is that the host application typically wants to interact with the framework instance and/or installed bundles/services from the outside. This is fairly easy to achieve, but there are some subtle issues to understand. This section presents the mechanisms for embedding Felix into a host application and the issues in doing so.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-Host%2FFelixInteraction"></A>Host/Felix Interaction</H2>

<P>In the section on <A href="#ApacheFelixFrameworkLaunchingandEmbedding-launching">launching</A> the framework above, the <TT>Felix</TT> class accepts a configuration property called <TT>felix.systembundle.activators</TT>, which is a list of bundle activator instances. These bundle activator instances provide a convenient way for host applications to interact with the Felix framework.</P>

<DIV class="panelMacro"><TABLE class="warningMacro"><COLGROUP><COL width="24"><COL></COLGROUP><TR><TD valign="top"><IMG src="https://cwiki.apache.org/confluence/images/icons/emoticons/forbidden.gif" width="16" height="16" align="absmiddle" alt="" border="0"></TD><TD><B>WARNING</B><BR>The <TT>felix.systembundle.activators</TT> configuration property is specific to the Felix framework implementation. If you want your code to work with other framework implementations, you should call <TT>init()</TT> on the framework instance and use <TT>getBundleContext()</TT> directly. Otherwise, the approach would be very similar.</TD></TR></TABLE></DIV>

<P>Each activator instance passed into the constructor effectively becomes part of the system bundle. This means that the <TT>start()</TT>/<TT>stop()</TT> methods of each activator instance in the list gets invoked when the system bundle's activator <TT>start()</TT>/<TT>stop()</TT> methods gets invoked, respectively. Each activator instance will be given the system bundle's <TT>BundleContext</TT> object so that they can interact with the framework. Consider following snippet of a bundle activator:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> class HostActivator <SPAN class="code-keyword">implements</SPAN> BundleActivator
{
    <SPAN class="code-keyword">private</SPAN> BundleContext m_context = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> void start(BundleContext context)
    {
        m_context = context;
    }

    <SPAN class="code-keyword">public</SPAN> void stop(BundleContext context)
    {
        m_context = <SPAN class="code-keyword">null</SPAN>;
    }

    <SPAN class="code-keyword">public</SPAN> Bundle[] getBundles()
    {
        <SPAN class="code-keyword">if</SPAN> (m_context != <SPAN class="code-keyword">null</SPAN>)
        {
            <SPAN class="code-keyword">return</SPAN> m_context.getBundles();
        }
        <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">null</SPAN>;
    }
}
</PRE>
</DIV></DIV>

<P>Given the above bundle activator, it is now possible to embed the Felix framework into a host application and interact with it as the following snippet illustrates:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">public</SPAN> class HostApplication
{
    <SPAN class="code-keyword">private</SPAN> HostActivator m_activator = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> Felix m_felix = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> HostApplication()
    {
        <SPAN class="code-comment">// Create a configuration property map.
</SPAN>        Map config = <SPAN class="code-keyword">new</SPAN> HashMap();
        <SPAN class="code-comment">// Create host activator;
</SPAN>        m_activator = <SPAN class="code-keyword">new</SPAN> HostActivator();
        List list = <SPAN class="code-keyword">new</SPAN> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <SPAN class="code-keyword">try</SPAN>
        {
            <SPAN class="code-comment">// Now create an instance of the framework with
</SPAN>            <SPAN class="code-comment">// our configuration properties.
</SPAN>            m_felix = <SPAN class="code-keyword">new</SPAN> Felix(config);
            <SPAN class="code-comment">// Now start Felix instance.
</SPAN>            m_felix.start();
        }
        <SPAN class="code-keyword">catch</SPAN> (Exception ex)
        {
            <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Could not create framework: &quot;</SPAN> + ex);
            ex.printStackTrace();
        }
    }

    <SPAN class="code-keyword">public</SPAN> Bundle[] getInstalledBundles()
    {
        <SPAN class="code-comment">// Use the system bundle activator to gain external
</SPAN>        <SPAN class="code-comment">// access to the set of installed bundles.
</SPAN>        <SPAN class="code-keyword">return</SPAN> m_activator.getBundles();
    }

    <SPAN class="code-keyword">public</SPAN> void shutdownApplication()
    {
        <SPAN class="code-comment">// Shut down the felix framework when stopping the
</SPAN>        <SPAN class="code-comment">// host application.
</SPAN>        m_felix.stop();
        m_felix.waitForStop(0);
    }
}
</PRE>
</DIV></DIV>

<P>Notice how the <TT>HostApplication.getInstalledBundles()</TT> method uses its activator instance to get access to the system bundle's context in order to interact with the embedded Felix framework instance. This approach provides the foundation for all interaction between the host application and the embedded framework instance.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-hostservices"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-ProvidingHostApplicationServices"></A>Providing Host Application Services</H2>

<P>Providing services from the host application to bundles inside the embedded Felix framework instance follows the basic approach laid out in <A href="#ApacheFelixFrameworkLaunchingandEmbedding-hostinteraction">above</A>. The main complication for providing a host application service to bundles is the fact that both the host application and the bundles must be using the same class definitions for the service interface classes. Since the host application cannot import classes from a bundle, this means that the service interface classes <B>must</B> be accessible on the class path, typically as part of the host application itself. The host application then must export the service interface package via the system bundle so that bundles installed into the embedded framework instance can import it. This is achieved using the <TT>org.osgi.framework.system.packages.extra</TT> configuration property previously presented.</P>

<P>Consider the follow simple property lookup service:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.service.lookup;

<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> Lookup
{
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">Object</SPAN> lookup(<SPAN class="code-object">String</SPAN> name);
}
</PRE>
</DIV></DIV>

<P>This package is simply part of the host application, which is potentially packaged into a JAR file and started with the &quot;<TT>java -jar</TT>&quot; command. Now consider the following host application bundle activator, which will be used to register/unregister the property lookup service when the embedded framework instance starts/stops:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.core;

<SPAN class="code-keyword">import</SPAN> java.util.Map;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleActivator;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleContext;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.ServiceRegistration;
<SPAN class="code-keyword">import</SPAN> host.service.lookup;

<SPAN class="code-keyword">public</SPAN> class HostActivator <SPAN class="code-keyword">implements</SPAN> BundleActivator
{
    <SPAN class="code-keyword">private</SPAN> Map m_lookupMap = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> BundleContext m_context = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> ServiceRegistration m_registration = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> HostActivator(Map lookupMap)
    {
        <SPAN class="code-comment">// Save a reference to the service's backing store.
</SPAN>        m_lookupMap = lookupMap;
    }

    <SPAN class="code-keyword">public</SPAN> void start(BundleContext context)
    {
        <SPAN class="code-comment">// Save a reference to the bundle context.
</SPAN>        m_context = context;
        <SPAN class="code-comment">// Create a property lookup service implementation.
</SPAN>        Lookup lookup = <SPAN class="code-keyword">new</SPAN> Lookup() {
            <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">Object</SPAN> lookup(<SPAN class="code-object">String</SPAN> name)
            {
                <SPAN class="code-keyword">return</SPAN> m_lookupMap.get(name);
            }
        };
        <SPAN class="code-comment">// Register the property lookup service and save
</SPAN>        <SPAN class="code-comment">// the service registration.
</SPAN>        m_registration = m_context.registerService(
            Lookup.class.getName(), lookup, <SPAN class="code-keyword">null</SPAN>);
    }

    <SPAN class="code-keyword">public</SPAN> void stop(BundleContext context)
    {
        <SPAN class="code-comment">// Unregister the property lookup service.
</SPAN>        m_registration.unregister();
        m_context = <SPAN class="code-keyword">null</SPAN>;
    }
}
</PRE>
</DIV></DIV>

<P>Given the above host application bundle activator, the following code snippet shows how the host application could create an embedded version of the Felix framework and provide the property lookup service to installed bundles:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.core;

<SPAN class="code-keyword">import</SPAN> java.util.List;
<SPAN class="code-keyword">import</SPAN> java.util.ArrayList;
<SPAN class="code-keyword">import</SPAN> java.util.Map;
<SPAN class="code-keyword">import</SPAN> java.util.HashMap;
<SPAN class="code-keyword">import</SPAN> host.service.lookup.Lookup;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.framework.Felix;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.framework.util.FelixConstants;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.Constants;

<SPAN class="code-keyword">public</SPAN> class HostApplication
{
    <SPAN class="code-keyword">private</SPAN> HostActivator m_activator = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> Felix m_felix = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> Map m_lookupMap = <SPAN class="code-keyword">new</SPAN> HashMap();

    <SPAN class="code-keyword">public</SPAN> HostApplication()
    {
        <SPAN class="code-comment">// Initialize the map <SPAN class="code-keyword">for</SPAN> the property lookup service.
</SPAN>        m_lookupMap.put(<SPAN class="code-quote">&quot;name1&quot;</SPAN>, <SPAN class="code-quote">&quot;value1&quot;</SPAN>);

        m_lookupMap.put(<SPAN class="code-quote">&quot;name2&quot;</SPAN>, <SPAN class="code-quote">&quot;value2&quot;</SPAN>);
        m_lookupMap.put(<SPAN class="code-quote">&quot;name3&quot;</SPAN>, <SPAN class="code-quote">&quot;value3&quot;</SPAN>);
        m_lookupMap.put(<SPAN class="code-quote">&quot;name4&quot;</SPAN>, <SPAN class="code-quote">&quot;value4&quot;</SPAN>);

        <SPAN class="code-comment">// Create a configuration property map.
</SPAN>        Map configMap = <SPAN class="code-keyword">new</SPAN> HashMap();
        <SPAN class="code-comment">// Export the host provided service <SPAN class="code-keyword">interface</SPAN> <SPAN class="code-keyword">package</SPAN>.
</SPAN>        configMap.put(Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,
            <SPAN class="code-quote">&quot;host.service.lookup; version=1.0.0&quot;</SPAN>);
        <SPAN class="code-comment">// Create host activator;
</SPAN>        m_activator = <SPAN class="code-keyword">new</SPAN> HostActivator(m_lookupMap);
        List list = <SPAN class="code-keyword">new</SPAN> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <SPAN class="code-keyword">try</SPAN>
        {
            <SPAN class="code-comment">// Now create an instance of the framework with
</SPAN>            <SPAN class="code-comment">// our configuration properties.
</SPAN>            m_felix = <SPAN class="code-keyword">new</SPAN> Felix(configMap);
            <SPAN class="code-comment">// Now start Felix instance.
</SPAN>            m_felix.start();
        }
        <SPAN class="code-keyword">catch</SPAN> (Exception ex)
        {
            <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Could not create framework: &quot;</SPAN> + ex);
            ex.printStackTrace();
        }
    }

    <SPAN class="code-keyword">public</SPAN> void shutdownApplication()
    {
        <SPAN class="code-comment">// Shut down the felix framework when stopping the
</SPAN>        <SPAN class="code-comment">// host application.
</SPAN>        m_felix.stop();
        m_felix.waitForStop(0);
    }
}
</PRE>
</DIV></DIV>

<P>Rather than having the host application bundle activator register the service, it is also possible for the the host application to simply get the bundle context from the bundle activator and register the service directly, but the presented approach is perhaps a little cleaner since it allows the host application to register/unregister the service when the system bundle starts/stops.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-hostserviceusage"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-UsingServicesProvidedbyBundles"></A>Using Services Provided by Bundles</H2>

<P>Using services provided by bundles follows the same general approach of using a host application bundle activator. The main complication for the host application using a service from a bundle is the fact that both the host application and the bundle must be using the same class definitions for the service interface classes. Since the host application cannot import classes from a bundle, this means that the service interface classes <B>must</B> be accessible on the class path, typically as part of the host application itself. The host application then must export the service interface package via the system bundle so that bundles installed into the embedded framework instance can import it. This is achieved using the <TT>org.osgi.framework.system.packages.extra</TT> configuration property previously presented.</P>

<P>Consider the following simple command service interface for which bundles provide implementations, such as might be used to create an extensible interactive shell:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.service.command;

<SPAN class="code-keyword">public</SPAN> class Command
{
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">String</SPAN> getName();
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">String</SPAN> getDescription();
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">boolean</SPAN> execute(<SPAN class="code-object">String</SPAN> commandline);
}
</PRE>
</DIV></DIV>

<P>This package is simply part of the host application, which is potentially packaged into a JAR file and started with the &quot;<TT>java -jar</TT>&quot; command. Now consider the previously introduced host application bundle activator below, which simply provides access to the system bundle context:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.core;

<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleActivator;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleContext;

<SPAN class="code-keyword">public</SPAN> class HostActivator <SPAN class="code-keyword">implements</SPAN> BundleActivator
{
    <SPAN class="code-keyword">private</SPAN> BundleContext m_context = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> void start(BundleContext context)
    {
        m_context = context;
    }

    <SPAN class="code-keyword">public</SPAN> void stop(BundleContext context)
    {
        m_context = <SPAN class="code-keyword">null</SPAN>;
    }

    <SPAN class="code-keyword">public</SPAN> BundleContext getContext()
    {
        <SPAN class="code-keyword">return</SPAN> m_context;
    }
}
</PRE>
</DIV></DIV>

<P>With this bundle activator, the host application can use command services provided by bundles installed inside its embedded Felix framework instance. The following code snippet illustrates one possible approach:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
<SPAN class="code-keyword">package</SPAN> host.core;

<SPAN class="code-keyword">import</SPAN> java.util.List;
<SPAN class="code-keyword">import</SPAN> java.util.ArrayList;
<SPAN class="code-keyword">import</SPAN> java.util.Map;
<SPAN class="code-keyword">import</SPAN> host.service.command.Command;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.framework.Felix;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.framework.util.FelixConstants;
<SPAN class="code-keyword">import</SPAN> org.apache.felix.framework.cache.BundleCache;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.Constants;
<SPAN class="code-keyword">import</SPAN> org.osgi.util.tracker.ServiceTracker;

<SPAN class="code-keyword">public</SPAN> class HostApplication
{
    <SPAN class="code-keyword">private</SPAN> HostActivator m_activator = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> Felix m_felix = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-keyword">private</SPAN> ServiceTracker m_tracker = <SPAN class="code-keyword">null</SPAN>;

    <SPAN class="code-keyword">public</SPAN> HostApplication()
    {
        <SPAN class="code-comment">// Create a configuration property map.
</SPAN>        Map configMap = <SPAN class="code-keyword">new</SPAN> HashMap();
        <SPAN class="code-comment">// Export the host provided service <SPAN class="code-keyword">interface</SPAN> <SPAN class="code-keyword">package</SPAN>.
</SPAN>        configMap.put(Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,
            <SPAN class="code-quote">&quot;host.service.command; version=1.0.0&quot;</SPAN>);
        <SPAN class="code-comment">// Create host activator;
</SPAN>        m_activator = <SPAN class="code-keyword">new</SPAN> HostActivator();
        List list = <SPAN class="code-keyword">new</SPAN> ArrayList();
        list.add(m_activator);
        configMap.put(FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list);

        <SPAN class="code-keyword">try</SPAN>
        {
            <SPAN class="code-comment">// Now create an instance of the framework with
</SPAN>            <SPAN class="code-comment">// our configuration properties.
</SPAN>            m_felix = <SPAN class="code-keyword">new</SPAN> Felix(configMap);
            <SPAN class="code-comment">// Now start Felix instance.
</SPAN>            m_felix.start();
        }
        <SPAN class="code-keyword">catch</SPAN> (Exception ex)
        {
            <SPAN class="code-object">System</SPAN>.err.println(<SPAN class="code-quote">&quot;Could not create framework: &quot;</SPAN> + ex);
            ex.printStackTrace();
        }

        m_tracker = <SPAN class="code-keyword">new</SPAN> ServiceTracker(
            m_activator.getContext(), Command.class.getName(), <SPAN class="code-keyword">null</SPAN>);
        m_tracker.open();
    }

    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">boolean</SPAN> execute(<SPAN class="code-object">String</SPAN> name, <SPAN class="code-object">String</SPAN> commandline)
    {
        <SPAN class="code-comment">// See <SPAN class="code-keyword">if</SPAN> any of the currently tracked command services
</SPAN>        <SPAN class="code-comment">// match the specified command name, <SPAN class="code-keyword">if</SPAN> so then execute it.
</SPAN>        <SPAN class="code-object">Object</SPAN>[] services = m_tracker.getServices();
        <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">int</SPAN> i = 0; (services != <SPAN class="code-keyword">null</SPAN>) &amp;&amp; (i &lt; services.length); i++)
        {
            <SPAN class="code-keyword">try</SPAN>
            {
                <SPAN class="code-keyword">if</SPAN> (((Command) services[i]).getName().equals(name))
                {
                    <SPAN class="code-keyword">return</SPAN> ((Command) services[i]).execute(commandline);
                }
            }
            <SPAN class="code-keyword">catch</SPAN> (Exception ex)
            {
                <SPAN class="code-comment">// Since the services returned by the tracker could become
</SPAN>                <SPAN class="code-comment">// invalid at any moment, we will <SPAN class="code-keyword">catch</SPAN> all exceptions, log
</SPAN>                <SPAN class="code-comment">// a message, and then ignore faulty services.
</SPAN>                <SPAN class="code-object">System</SPAN>.err.println(ex);
            }
        }
        <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">false</SPAN>;
    }

    <SPAN class="code-keyword">public</SPAN> void shutdownApplication()
    {
        <SPAN class="code-comment">// Shut down the felix framework when stopping the
</SPAN>        <SPAN class="code-comment">// host application.
</SPAN>        m_felix.stop();
        m_felix.waitForStop(0);
    }
}
</PRE>
</DIV></DIV>

<P>The above example is overly simplistic with respect to concurrency issues and error conditions, but it demonstrates the overall approach for using bundle-provided services from the host application.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-servicereflection"></A></P>

<H3><A name="ApacheFelixFrameworkLaunchingandEmbedding-UsingBundleServicesviaReflection"></A>Using Bundle Services via Reflection</H3>

<P>It possible for the host application to use services provided by bundles without having access to the service interface classes and thus not needing to put the service interface classes on the class path. To do this, the host application uses the same general approach to acquire the system bundle context object, which it can use to look up service objects. Using either an LDAP filter or the service interface class name, the host application can retrieve the service object and then use standard Java reflection to invoke methods on the service object.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-serviceother"></A></P>

<H3><A name="ApacheFelixFrameworkLaunchingandEmbedding-OtherApproaches"></A>Other Approaches</H3>

<P>The <A href="http://code.google.com/p/transloader/" class="external-link" rel="nofollow">Transloader</A> project is another attempt at dealing with issues of classes loaded from different class loaders and may be of interest.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-caveat"></A></P>

<H1><A name="ApacheFelixFrameworkLaunchingandEmbedding-Caveat"></A>Caveat</H1>

<P>The code in this document has not been thoroughly tested nor even compiled and may be out of date with respect to the current Felix source code. If you find errors please report them so the that they can be corrected.</P>

<P><A name="ApacheFelixFrameworkLaunchingandEmbedding-feedback"></A></P>

<H2><A name="ApacheFelixFrameworkLaunchingandEmbedding-Feedback"></A>Feedback</H2>

<P>Subscribe to the Felix users mailing list by sending a message to <A href="mailto:users-subscribe@felix.apache.org" class="external-link" rel="nofollow">users-subscribe@felix.apache.org</A>; after subscribing, email questions or feedback to <A href="mailto:users@felix.apache.org" class="external-link" rel="nofollow">users@felix.apache.org</A>.</P>
        <DIV class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
Last modified by rubytuesdaydono on Thu May 03 11:33:59 EDT 2012
        </DIV>
        <DIV class="trademarkFooter">
Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners.
        </DIV>
    </DIV>
  </BODY>
</HTML>

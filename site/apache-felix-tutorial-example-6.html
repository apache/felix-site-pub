
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Felix - Apache Felix Tutorial Example 6</TITLE>
    <LINK rel="stylesheet" href="http://felix.apache.org/site/media.data/site.css" type="text/css" media="all">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY>
    <DIV class="title"><DIV class="logo"><A href="http://felix.apache.org/site/index.html"><IMG border="0" alt="Apache Felix" src="http://felix.apache.org/site/media.data/logo.png"></A></DIV><DIV class="header"><A href="http://www.apache.org/"><IMG border="0" alt="Apache" src="http://felix.apache.org/site/media.data/apache.png"></A></DIV></DIV>
    <DIV class="menu">
<UL>
	<LI><A href="news.html" title="news">news</A></LI>
	<LI><A href="http://www.apache.org/licenses/" class="external-link" rel="nofollow">license</A></LI>
	<LI><A href="http://felix.apache.org/site/downloads.cgi" class="external-link" rel="nofollow">downloads</A></LI>
	<LI><A href="documentation.html" title="documentation">documentation</A></LI>
	<LI><A href="mailinglists.html" title="mailinglists">mailing lists</A></LI>
	<LI><A href="contributing.html" title="Contributing">contributing</A></LI>
	<LI><A href="http://www.apache.org/" class="external-link" rel="nofollow">asf</A></LI>
	<LI><A href="http://www.apache.org/security/" class="external-link" rel="nofollow">security</A></LI>
	<LI><A href="http://www.apache.org/foundation/sponsorship.html" class="external-link" rel="nofollow">sponsorship</A></LI>
	<LI><A href="http://www.apache.org/foundation/thanks.html" class="external-link" rel="nofollow">sponsors</A>
<!-- ApacheCon Ad -->
<IFRAME src="http://www.apache.org/ads/button.html" style="border-width:0; float: left" frameborder="0" scrolling="no" width="135" height="135"></IFRAME>
<P style="height: 100px">
<!-- ApacheCon Ad --></LI>
</UL>
    </DIV>
    <DIV class="main">
<H1><A name="ApacheFelixTutorialExample6-Example6SpellCheckerServiceBundle"></A>Example 6 - Spell Checker Service Bundle</H1>

<P><EM>(This example should be rewritten to use the Service Tracker.)</EM></P>

<P>In this example, we complicate things further by defining a new service that uses an arbitrary number of dictionary services to perform its function. More precisely, we define a spell checker service will aggregate all dictionary services and provide another service that allows us to spell check passages using our underlying dictionary services to verify the spelling of words. Our bundle will only provide the spell checker service if there is at least one dictionary service available. First, we will start by defining the spell checker service interface in a file called <TT>SpellChecker.java</TT>:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/*
 * Apache Felix OSGi tutorial.
**/

<SPAN class="code-keyword">package</SPAN> tutorial.example6.service;

/**
 * A simple service <SPAN class="code-keyword">interface</SPAN> that defines a spell checker service.
 * A spell checker service checks the spelling of all words in a
 * given passage. A passage is any number of words separated by
 * a space character and the following punctuation marks: comma,
 * period, exclamation mark, question mark, semi-colon, and colon.
**/
<SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> SpellChecker
{
    /**
     * Checks a given passage <SPAN class="code-keyword">for</SPAN> spelling errors. A passage is any
     * number of words separated by a space and any of the following
     * punctuation marks: comma (,), period (.), exclamation mark (!),
     * question mark (?), semi-colon (;), and colon(:).
     * @param passage the passage to spell check.
     * @<SPAN class="code-keyword">return</SPAN> An array of misspelled words or <SPAN class="code-keyword">null</SPAN> <SPAN class="code-keyword">if</SPAN> no
     *         words are misspelled.
    **/
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">String</SPAN>[] check(<SPAN class="code-object">String</SPAN> passage);
}
</PRE>
</DIV></DIV>

<P>The service interface is quite simple, with only one method that needs to be implemented. Notice that we put the service interface in the package <TT>tutorial.example6.service</TT>, instead of just putting it in <TT>tutorial.example6</TT>. We did this because we need to share the interface definition with other bundles, therefore it is better to separate service interfaces that need to be shared from code that does not need to be shared. Such an approach ensures a strong separation between interface and implementation.</P>

<P>In the following bundle source code, the bundle needs to create a complete list of all dictionary services; this is somewhat tricky and must be done carefully. First, the bundle uses its bundle context to register itself as a service event listener, then it queries for all currently available dictionary services. After creating the list of dictionary services, the bundle then registers its spell checker service if and only if there is at least one dictionary service available. These actions must be performed in a synchronized block to avoid interference from service events. Additionally, since the bundle is monitoring the dynamic availability of the dictionary services, when the number of dictionary services falls to zero or increases from zero, the bundle must unregister and register its spell checker service, respectively. We implement our bundle in a file called <TT>Activator.java</TT>:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/*
 * Apache Felix OSGi tutorial.
**/

<SPAN class="code-keyword">package</SPAN> tutorial.example6;

<SPAN class="code-keyword">import</SPAN> java.io.BufferedReader;
<SPAN class="code-keyword">import</SPAN> java.io.InputStreamReader;
<SPAN class="code-keyword">import</SPAN> java.io.IOException;
<SPAN class="code-keyword">import</SPAN> java.util.ArrayList;
<SPAN class="code-keyword">import</SPAN> java.util.HashMap;
<SPAN class="code-keyword">import</SPAN> java.util.StringTokenizer;

<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleActivator;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.BundleContext;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.ServiceRegistration;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.ServiceReference;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.ServiceListener;
<SPAN class="code-keyword">import</SPAN> org.osgi.framework.ServiceEvent;

<SPAN class="code-keyword">import</SPAN> tutorial.example2.service.DictionaryService;
<SPAN class="code-keyword">import</SPAN> tutorial.example6.service.SpellChecker;

/**
 * This class <SPAN class="code-keyword">implements</SPAN> a bundle that <SPAN class="code-keyword">implements</SPAN> a spell
 * checker service. The spell checker service uses all available
 * dictionary services to check <SPAN class="code-keyword">for</SPAN> the existence of words in
 * a given sentence. This bundle not only monitors the dynamic
 * availability of dictionary services, but it manages the
 * aggregation of all available dictionary services as they
 * arrive and depart. The spell checker service is only registered
 * <SPAN class="code-keyword">if</SPAN> there are dictionary services available, thus the spell
 * checker service will appear and disappear as dictionary
 * services appear and disappear, respectively.
**/
<SPAN class="code-keyword">public</SPAN> class Activator <SPAN class="code-keyword">implements</SPAN> BundleActivator, ServiceListener
{
    <SPAN class="code-comment">// Bundle's context.
</SPAN>    <SPAN class="code-keyword">private</SPAN> BundleContext m_context = <SPAN class="code-keyword">null</SPAN>;
    <SPAN class="code-comment">// List of available dictionary service references.
</SPAN>    <SPAN class="code-keyword">private</SPAN> ArrayList m_refList = <SPAN class="code-keyword">new</SPAN> ArrayList();
    <SPAN class="code-comment">// Maps service references to service objects.
</SPAN>    <SPAN class="code-keyword">private</SPAN> HashMap m_refToObjMap = <SPAN class="code-keyword">new</SPAN> HashMap();
    <SPAN class="code-comment">// The spell checker service registration.
</SPAN>    <SPAN class="code-keyword">private</SPAN> ServiceRegistration m_reg = <SPAN class="code-keyword">null</SPAN>;

    /**
     * Implements BundleActivator.start(). Adds itself
     * as a service listener and queries <SPAN class="code-keyword">for</SPAN> all currently
     * available dictionary services. Any available dictionary
     * services are added to the service reference list. If
     * dictionary services are found, then the spell checker
     * service is registered.
     * @param context the framework context <SPAN class="code-keyword">for</SPAN> the bundle.
    **/
    <SPAN class="code-keyword">public</SPAN> void start(BundleContext context) <SPAN class="code-keyword">throws</SPAN> Exception
    {
        m_context = context;

        <SPAN class="code-keyword">synchronized</SPAN> (m_refList)
        {
            <SPAN class="code-comment">// Listen <SPAN class="code-keyword">for</SPAN> events pertaining to dictionary services.
</SPAN>            m_context.addServiceListener(<SPAN class="code-keyword">this</SPAN>,
                <SPAN class="code-quote">&quot;(&amp;(objectClass=&quot;</SPAN> + DictionaryService.class.getName() + <SPAN class="code-quote">&quot;)&quot;</SPAN> +
                <SPAN class="code-quote">&quot;(Language=*))&quot;</SPAN>);

            <SPAN class="code-comment">// Query <SPAN class="code-keyword">for</SPAN> all dictionary services.
</SPAN>            ServiceReference[] refs = m_context.getServiceReferences(
                DictionaryService.class.getName(), <SPAN class="code-quote">&quot;(Language=*)&quot;</SPAN>);

            <SPAN class="code-comment">// Add any dictionaries to the service reference list.
</SPAN>            <SPAN class="code-keyword">if</SPAN> (refs != <SPAN class="code-keyword">null</SPAN>)
            {
                <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">int</SPAN> i = 0; i &lt; refs.length; i++)
                {
                    <SPAN class="code-comment">// Get the service object.
</SPAN>                    <SPAN class="code-object">Object</SPAN> service = m_context.getService(refs[i]);

                    <SPAN class="code-comment">// Make that the service is not being duplicated.
</SPAN>                    <SPAN class="code-keyword">if</SPAN> ((service != <SPAN class="code-keyword">null</SPAN>) &amp;&amp;
                        (m_refToObjMap.get(refs[i]) == <SPAN class="code-keyword">null</SPAN>))
                    {
                        <SPAN class="code-comment">// Add to the reference list.
</SPAN>                        m_refList.add(refs[i]);
                        <SPAN class="code-comment">// Map reference to service object <SPAN class="code-keyword">for</SPAN> easy look up.
</SPAN>                        m_refToObjMap.put(refs[i], service);
                    }
                }

                <SPAN class="code-comment">// Register spell checker service <SPAN class="code-keyword">if</SPAN> there are any
</SPAN>                <SPAN class="code-comment">// dictionary services.
</SPAN>                <SPAN class="code-keyword">if</SPAN> (m_refList.size() &gt; 0)
                {
                    m_reg = m_context.registerService(
                        SpellChecker.class.getName(),
                        <SPAN class="code-keyword">new</SPAN> SpellCheckerImpl(), <SPAN class="code-keyword">null</SPAN>);
                }
            }
        }
    }

    /**
     * Implements BundleActivator.stop(). Does nothing since
     * the framework will automatically unregister any registered services,
     * release any used services, and remove any event listeners.
     * @param context the framework context <SPAN class="code-keyword">for</SPAN> the bundle.
    **/
    <SPAN class="code-keyword">public</SPAN> void stop(BundleContext context)
    {
        <SPAN class="code-comment">// NOTE: The services automatically released.
</SPAN>    }

    /**
     * Implements ServiceListener.serviceChanged(). Monitors
     * the arrival and departure of dictionary services, adding and
     * removing them from the service reference list, respectively.
     * In the <SPAN class="code-keyword">case</SPAN> where no more dictionary services are available,
     * the spell checker service is unregistered. As soon as any dictionary
     * service becomes available, the spell checker service is
     * reregistered.
     * @param event the fired service event.
    **/
    <SPAN class="code-keyword">public</SPAN> void serviceChanged(ServiceEvent event)
    {
        <SPAN class="code-keyword">synchronized</SPAN> (m_refList)
        {
            <SPAN class="code-comment">// Add the <SPAN class="code-keyword">new</SPAN> dictionary service to the service list.
</SPAN>            <SPAN class="code-keyword">if</SPAN> (event.getType() == ServiceEvent.REGISTERED)
            {
                <SPAN class="code-comment">// Get the service object.
</SPAN>                <SPAN class="code-object">Object</SPAN> service = m_context.getService(event.getServiceReference());

                <SPAN class="code-comment">// Make that the service is not being duplicated.
</SPAN>                <SPAN class="code-keyword">if</SPAN> ((service != <SPAN class="code-keyword">null</SPAN>) &amp;&amp;
                    (m_refToObjMap.get(event.getServiceReference()) == <SPAN class="code-keyword">null</SPAN>))
                {
                    <SPAN class="code-comment">// Add to the reference list.
</SPAN>                    m_refList.add(event.getServiceReference());
                    <SPAN class="code-comment">// Map reference to service object <SPAN class="code-keyword">for</SPAN> easy look up.
</SPAN>                    m_refToObjMap.put(event.getServiceReference(), service);

                    <SPAN class="code-comment">// Register spell checker service <SPAN class="code-keyword">if</SPAN> necessary.
</SPAN>                    <SPAN class="code-keyword">if</SPAN> (m_reg == <SPAN class="code-keyword">null</SPAN>)
                    {
                        m_reg = m_context.registerService(
                            SpellChecker.class.getName(),
                            <SPAN class="code-keyword">new</SPAN> SpellCheckerImpl(), <SPAN class="code-keyword">null</SPAN>);
                    }
                }
                <SPAN class="code-keyword">else</SPAN> <SPAN class="code-keyword">if</SPAN> (service != <SPAN class="code-keyword">null</SPAN>)
                {
                    m_context.ungetService(event.getServiceReference());
                }
            }
            <SPAN class="code-comment">// Remove the departing service from the service list.
</SPAN>            <SPAN class="code-keyword">else</SPAN> <SPAN class="code-keyword">if</SPAN> (event.getType() == ServiceEvent.UNREGISTERING)
            {
                <SPAN class="code-comment">// Make sure the service is in the list.
</SPAN>                <SPAN class="code-keyword">if</SPAN> (m_refToObjMap.get(event.getServiceReference()) != <SPAN class="code-keyword">null</SPAN>)
                {
                    <SPAN class="code-comment">// Unget the service object.
</SPAN>                    m_context.ungetService(event.getServiceReference());
                    <SPAN class="code-comment">// Remove service reference.
</SPAN>                    m_refList.remove(event.getServiceReference());
                    <SPAN class="code-comment">// Remove service reference from map.
</SPAN>                    m_refToObjMap.remove(event.getServiceReference());

                    <SPAN class="code-comment">// If there are no more dictionary services,
</SPAN>                    <SPAN class="code-comment">// then unregister spell checker service.
</SPAN>                    <SPAN class="code-keyword">if</SPAN> (m_refList.size() == 0)
                    {
                        m_reg.unregister();
                        m_reg = <SPAN class="code-keyword">null</SPAN>;
                    }
                }
            }
        }
    }

    /**
     * A <SPAN class="code-keyword">private</SPAN> <SPAN class="code-keyword">inner</SPAN> class that <SPAN class="code-keyword">implements</SPAN> a spell checker service;
     * see SpellChecker <SPAN class="code-keyword">for</SPAN> details of the service.
    **/
    <SPAN class="code-keyword">private</SPAN> class SpellCheckerImpl <SPAN class="code-keyword">implements</SPAN> SpellChecker
    {
        /**
         * Implements SpellChecker.check(). Checks the
         * given passage <SPAN class="code-keyword">for</SPAN> misspelled words.
         * @param passage the passage to spell check.
         * @<SPAN class="code-keyword">return</SPAN> An array of misspelled words or <SPAN class="code-keyword">null</SPAN> <SPAN class="code-keyword">if</SPAN> no
         *         words are misspelled.
        **/
        <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">String</SPAN>[] check(<SPAN class="code-object">String</SPAN> passage)
        {
            <SPAN class="code-comment">// No misspelled words <SPAN class="code-keyword">for</SPAN> an empty string.
</SPAN>            <SPAN class="code-keyword">if</SPAN> ((passage == <SPAN class="code-keyword">null</SPAN>) || (passage.length() == 0))
            {
                <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">null</SPAN>;
            }

            ArrayList errorList = <SPAN class="code-keyword">new</SPAN> ArrayList();

            <SPAN class="code-comment">// Tokenize the passage using spaces and punctionation.
</SPAN>            StringTokenizer st = <SPAN class="code-keyword">new</SPAN> StringTokenizer(passage, <SPAN class="code-quote">&quot; ,.!?;:&quot;</SPAN>);

            <SPAN class="code-comment">// Lock the service list.
</SPAN>            <SPAN class="code-keyword">synchronized</SPAN> (m_refList)
            {
                <SPAN class="code-comment">// Loop through each word in the passage.
</SPAN>                <SPAN class="code-keyword">while</SPAN> (st.hasMoreTokens())
                {
                    <SPAN class="code-object">String</SPAN> word = st.nextToken();

                    <SPAN class="code-object">boolean</SPAN> correct = <SPAN class="code-keyword">false</SPAN>;

                    <SPAN class="code-comment">// Check each available dictionary <SPAN class="code-keyword">for</SPAN> the current word.
</SPAN>                    <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">int</SPAN> i = 0; (!correct) &amp;&amp; (i &lt; m_refList.size()); i++)
                    {
                        DictionaryService dictionary =
                            (DictionaryService) m_refToObjMap.get(m_refList.get(i));

                        <SPAN class="code-keyword">if</SPAN> (dictionary.checkWord(word))
                        {
                            correct = <SPAN class="code-keyword">true</SPAN>;
                        }
                    }

                    <SPAN class="code-comment">// If the word is not correct, then add it
</SPAN>                    <SPAN class="code-comment">// to the incorrect word list.
</SPAN>                    <SPAN class="code-keyword">if</SPAN> (!correct)
                    {
                        errorList.add(word);
                    }
                }
            }

            <SPAN class="code-comment">// Return <SPAN class="code-keyword">null</SPAN> <SPAN class="code-keyword">if</SPAN> no words are incorrect.
</SPAN>            <SPAN class="code-keyword">if</SPAN> (errorList.size() == 0)
            {
                <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">null</SPAN>;
            }

            <SPAN class="code-comment">// Return the array of incorrect words.
</SPAN>            <SPAN class="code-keyword">return</SPAN> (<SPAN class="code-object">String</SPAN>[]) errorList.toArray(<SPAN class="code-keyword">new</SPAN> <SPAN class="code-object">String</SPAN>[errorList.size()]);
        }
    }
}
</PRE>
</DIV></DIV>

<P>Note that we do not need to unregister the service in stop() method, because the OSGi framework will automatically do so for us. The spell checker service that we have implemented is very simple; it simply parses a given passage into words and then loops through all available dictionary services for each word until it determines that the word is correct. Any incorrect words are added to an error list that will be returned to the caller. This solution is not optimal and is only intended for educational purposes. Next, we create a <TT>manifest.mf</TT> file that contains the meta-data for our bundle:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>Bundle-Name: Spell checker service
Bundle-Description: A bundle that implements a simple spell checker service
Bundle-Vendor: Richard Hall
Bundle-Version: 1.0.0
Bundle-Activator: tutorial.example6.Activator
Export-Package: tutorial.example6.service
Import-Package: org.osgi.framework,
 tutorial.example2.service
</PRE>
</DIV></DIV>

<P>We specify which class used to activate the bundle via the <TT>Bundle-Activator</TT> attribute. Our bundle exports the spell checker service interface using the <TT>Export-Package</TT> attribute and imports the OSGi core framework and dictionary service interface packages using the <TT>Import-Package</TT> attribute. (Note: Make sure your manifest file ends in a trailing carriage return or else the last line will be ignored.)</P>

<P>To compile our source, we need to have the <TT>felix.jar</TT> file (found in Felix' <TT>bin</TT> directory) and the example2.jar file in our class path. We compile the source file using a command like:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>javac -d c:\classes *.java
</PRE>
</DIV></DIV>

<P>This command compiles all source files and outputs the generated classes into a subdirectory of the <TT>c:\classes</TT> directory; this subdirectory is <TT>tutorial\example6</TT>, named after the package we specified in the source file. For the above command to work, the <TT>c:\classes</TT> directory must exist. After compiling, we need to create a JAR file containing the generated package directories. We will also add our manifest file that contains the bundle's meta-data to the JAR file. To create the JAR file, we issue the command:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>jar cfm example6.jar manifest.mf -C c:\classes tutorial\example6
</PRE>
</DIV></DIV>

<P>This command creates a JAR file using the manifest file we created and includes all of the classes in the <TT>tutorial\example6</TT> directory inside of the <TT>c:\classes</TT> directory. Once the JAR file is created, we are ready to install and start the bundle.</P>

<P>To run Felix, we follow the instructions described in usage.html. When we start Felix, it asks for a profile name, we will put all of our bundles in a profile named <TT>tutorial</TT>. After running Felix, we should stop all tutorial bundles except for the service bundles. Use the <TT>lb</TT> command to make sure that only the bundles from Example 2 and Example 2b are active; use the <TT>start</TT> and <TT>stop</TT> commands as appropriate to start and stop the various tutorial bundles, respectively. (Note: Felix uses some bundles to provide its command shell, so do not stop these bundles.) Now we can install and start our spell checker service bundle. Assuming that we created our bundle in the directory <TT>c:\tutorial</TT>, we can install and start it in Felix' shell using the following command:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>start file:/c:/tutorial/example6.jar
</PRE>
</DIV></DIV>

<P>The above command installs and starts the bundle in a single step; it is also possible to install and start the bundle in two steps by using the Felix <TT>install</TT> and <TT>start</TT> shell commands. To stop the bundle, use the Felix <TT>stop</TT> shell command. Using the Felix shell <TT>lb</TT> command to get the bundle identifier number for our spell checker service bundle and we can stop and restart it at will using the <TT>stop</TT> and <TT>start</TT> commands, respectively. Using the <TT>services</TT> command, we can see which services are currently available in the OSGi framework, including our dictionary and spell checker services. We can experiment with our spell checker service's dynamic availability by stopping the dictionary service bundles; when both dictionary services are stopped, the <TT>services</TT> command will reveal that our bundle is no longer offering its spell checker service. Likewise, when the dictionary services comeback, so will our spell checker service. We create a client for our spell checker service in Example 7. To exit Felix, we use the <TT>shutdown</TT> command.</P>
        <DIV class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
Last modified by heavy@ungoverned.org on 2011-03-17 10:48:36.0
        </DIV>
        <DIV class="trademarkFooter">
Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners.
        </DIV>
    </DIV>
  </BODY>
</HTML>


<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML>
  <HEAD>
    <TITLE>Apache Felix - Apache Felix Tutorial Example 8</TITLE>
    <LINK rel="stylesheet" href="http://felix.apache.org/site/media.data/site.css" type="text/css" media="all">
    <META http-equiv="Content-Type" content="text/html;charset=UTF-8">
  </HEAD>
  <BODY>
    <DIV class="title"><DIV class="logo"><A href="http://felix.apache.org/site/index.html"><IMG border="0" alt="Apache Felix" src="http://felix.apache.org/site/media.data/logo.png"></A></DIV><DIV class="header"><A href="http://www.apache.org/"><IMG border="0" alt="Apache" src="http://felix.apache.org/site/media.data/apache.png"></A></DIV></DIV>
    <DIV class="menu">
<UL>
	<LI><A href="news.html" title="news">news</A></LI>
	<LI><A href="http://www.apache.org/licenses/" class="external-link" rel="nofollow">license</A></LI>
	<LI><A href="http://felix.apache.org/site/downloads.cgi" class="external-link" rel="nofollow">downloads</A></LI>
	<LI><A href="documentation.html" title="documentation">documentation</A></LI>
	<LI><A href="mailinglists.html" title="mailinglists">mailing lists</A></LI>
	<LI><A href="contributing.html" title="Contributing">contributing</A></LI>
	<LI><A href="http://www.apache.org/" class="external-link" rel="nofollow">asf</A></LI>
	<LI><A href="http://www.apache.org/security/" class="external-link" rel="nofollow">security</A></LI>
	<LI><A href="http://www.apache.org/foundation/sponsorship.html" class="external-link" rel="nofollow">sponsorship</A></LI>
	<LI><A href="http://www.apache.org/foundation/thanks.html" class="external-link" rel="nofollow">sponsors</A>
<!-- ApacheCon Ad -->
<IFRAME src="http://www.apache.org/ads/button.html" style="border-width:0; float: left" frameborder="0" scrolling="no" width="135" height="135"></IFRAME>
<P style="height: 100px">
<!-- ApacheCon Ad --></LI>
</UL>
    </DIV>
    <DIV class="main">
<H1><A name="ApacheFelixTutorialExample8-Example8SpellCheckerServiceusingServiceBinder"></A>Example 8 - Spell Checker Service using Service Binder</H1>

<P><EM>[Note: The Service Binder was the original project to attempt to automate service dependency management for the OSGi platform and was the inspiration for Declarative Services introduced in OSGi R4. The Service Binder is no longer under active development, but this example is kept in the tutorial for historical purposes. New projects should consider using one of the other dependency injection technologies (e.g., Declarative Services, Dependency Manager, or iPOJO).]</EM></P>

<P>The purpose of this example is to re-implement the spell checker service in Example 6, but to do so using the Service Binder; to complete this, we must download the <A href="https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=FELIX&title=link%3F&linkCreation=true&fromPageId=59947" class="createlink">Service Binder</A> bundle. The Service Binder bundle is needed to compile the example and at run time to execute the example.</P>

<P>The spell checker service of Example 6 was complex because it needed to aggregate all available dictionary services and monitor their dynamic availability. In addition, the spell checker service's own availability was dependent upon the availability of dictionary services; in other words, the spell checker service had a dynamic, one-to-many dependency on dictionary services. As it turns out, service dependencies are not managed at all by the OSGi framework and end up being the responsibility of the application developer. The Service Binder tries to eliminate complex and error-prone service dependency handling by automating it. To do this, the Service Binder replaces the BundleActivator code with a generic bundle activator that parses an XML file that describes the instances we want to create and their service dependencies. Instead of writing a lot of complex code, we simply write a declarative XML file. For an example, consider the following code for the new service's bundle activator in a file called <TT>Activator.java</TT>:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/*
 * Apache Felix OSGi tutorial.
**/

<SPAN class="code-keyword">package</SPAN> tutorial.example8;

<SPAN class="code-keyword">import</SPAN> org.apache.felix.servicebinder.GenericActivator;

/**
 * This example re-<SPAN class="code-keyword">implements</SPAN> the spell checker service of
 * Example 6 using the Service Binder. The Service Binder
 * greatly simplifies creating OSGi applications by
 * essentially eliminating the need to write OSGi-related
 * code; instead of writing OSGi code <SPAN class="code-keyword">for</SPAN> your bundle, you
 * create a simple XML file to describe your bundle's service
 * dependencies. This class <SPAN class="code-keyword">extends</SPAN> the <SPAN class="code-keyword">generic</SPAN> bundle activator;
 * it does not provide any additional functionality. All
 * functionality <SPAN class="code-keyword">for</SPAN> service-related tasks, such as look-up and
 * binding, is handled by the <SPAN class="code-keyword">generic</SPAN> activator base class using
 * data from the metadata.xml file. All application
 * functionality is defined in the SpellCheckerImpl.java
 * file.
**/

<SPAN class="code-keyword">public</SPAN> class Activator <SPAN class="code-keyword">extends</SPAN> GenericActivator
{
}
</PRE>
</DIV></DIV>

<P>All custom functionality has been removed from the bundle activator, it is only necessary to subclass the generic activator exported by the Service Binder. The generic activator performs its task by parsing an XML meta-data file that describes what instances should be created and what their service dependencies are; for our example, we create a file called <TT>metadata.xml</TT> that contains the instance and service dependency meta-data:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;bundle&gt;
  &lt;!--
    -- This meta-data file instructs the Service Binder to
    -- create one instance of &quot;SpellCheckerImpl&quot;. It also
    -- tells the generic activator that this instance implements the
    -- &quot;SpellChecker&quot; service interface and that it has an
    -- aggregate dependency on &quot;DictionaryService&quot; services. Since
    -- the service dependency on dictionary services has a lower
    -- cardinality of one, the generic activator will create the instance
    -- and offer its spell checker service only when there is at least
    -- one dictionary service available. The service dependency is
    -- &quot;dynamic&quot;, which means that dictionary service availability
    -- will be monitored dynamically at runtime and it also tells the
    -- generic activator which methods to call when adding and removing
    -- dictionary services.
    --&gt;
  &lt;instance class=&quot;tutorial.example8.SpellCheckerImpl&quot;&gt;
    &lt;service interface=&quot;tutorial.example6.service.SpellChecker&quot;/&gt;
    &lt;requires
      service=&quot;tutorial.example2.service.DictionaryService&quot;
      filter=&quot;(Language=*)&quot;
      cardinality=&quot;1..n&quot;
      policy=&quot;dynamic&quot;
      bind-method=&quot;addDictionary&quot;
      unbind-method=&quot;removeDictionary&quot;
    /&gt;
  &lt;/instance&gt;
&lt;/bundle&gt;
</PRE>
</DIV></DIV>

<P>The above meta-data tells the generic activator to create one instance of <TT>tutorial.example8.SpellCheckerImpl</TT>, which we will define next. The meta-data also tells the generic activator that the instance has an aggregate service dependency (in this case, one-to-many) on dictionary services and that the services should be tracked dynamically. It also specifies the bind and unbind methods that should be called on the instance when dictionary services appear and disappear. It is important to understand that the generic activator is constantly trying to maintain the instances defined in the meta-data file. At any given point in time, a specific instance may be valid (if all service dependencies are satisfied) or invalid (if any service dependencies are unsatisfied), but at all times the generic activator is trying to get the declared instances into a valid state. The code for our new spell checker service is very similar to the implementation in Example 6, but it is no longer implemented as an inner class of the activator. We define the new spell checker service in a file called <TT>SpellCheckerImpl.java</TT> as follows:</P>

<DIV class="code panel" style="border-width: 1px;"><DIV class="codeContent panelContent">
<PRE class="code-java">
/*
 * Apache Felix OSGi tutorial.
**/

<SPAN class="code-keyword">package</SPAN> tutorial.example8;

<SPAN class="code-keyword">import</SPAN> java.io.BufferedReader;
<SPAN class="code-keyword">import</SPAN> java.io.InputStreamReader;
<SPAN class="code-keyword">import</SPAN> java.io.IOException;
<SPAN class="code-keyword">import</SPAN> java.util.ArrayList;
<SPAN class="code-keyword">import</SPAN> java.util.StringTokenizer;

<SPAN class="code-keyword">import</SPAN> tutorial.example2.service.DictionaryService;
<SPAN class="code-keyword">import</SPAN> tutorial.example6.service.SpellChecker;

/**
 * This class re-<SPAN class="code-keyword">implements</SPAN> the spell checker service of Example 6.
 * This service implementation behaves exactly like the one in
 * Example 6, specifically, it aggregates all available dictionary
 * services, monitors their dynamic availability, and only offers
 * the spell checker service <SPAN class="code-keyword">if</SPAN> there are dictionary services
 * available. The service implementation is greatly simplified,
 * though, by using the Service Binder. Notice that there is no OSGi
 * references in the application code; instead, the metadata.xml
 * file describes the service dependencies, which is read by the
 * Service Binder to automatically manage the dependencies and
 * register the spell checker service as appropriate.
**/
<SPAN class="code-keyword">public</SPAN> class SpellCheckerImpl <SPAN class="code-keyword">implements</SPAN> SpellChecker
{
    <SPAN class="code-comment">// List of service objects.
</SPAN>    <SPAN class="code-keyword">private</SPAN> ArrayList m_svcObjList = <SPAN class="code-keyword">new</SPAN> ArrayList();

    /**
     * This method is used by the Service Binder to add
     * <SPAN class="code-keyword">new</SPAN> dictionaries to the spell checker service.
     * @param dictionary the dictionary to add to the spell
     *                   checker service.
    **/
    <SPAN class="code-keyword">public</SPAN> void addDictionary(DictionaryService dictionary)
    {
        <SPAN class="code-comment">// Lock list and add service object.
</SPAN>        <SPAN class="code-keyword">synchronized</SPAN> (m_svcObjList)
        {
            m_svcObjList.add(dictionary);
        }
    }

    /**
     * This method is used by the Service Binder to remove
     * dictionaries from the spell checker service.
     * @param dictionary the dictionary to remove from the spell
     *                   checker service.
    **/
    <SPAN class="code-keyword">public</SPAN> void removeDictionary(DictionaryService dictionary)
    {
        <SPAN class="code-comment">// Lock list and remove service object.
</SPAN>        <SPAN class="code-keyword">synchronized</SPAN> (m_svcObjList)
        {
            m_svcObjList.remove(dictionary);
        }
    }

    /**
     * Checks a given passage <SPAN class="code-keyword">for</SPAN> spelling errors. A passage is any
     * number of words separated by a space and any of the following
     * punctuation marks: comma (,), period (.), exclamation mark (!),
     * question mark (?), semi-colon (;), and colon(:).
     * @param passage the passage to spell check.
     * @<SPAN class="code-keyword">return</SPAN> An array of misspelled words or <SPAN class="code-keyword">null</SPAN> <SPAN class="code-keyword">if</SPAN> no
     *         words are misspelled.
    **/
    <SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">String</SPAN>[] check(<SPAN class="code-object">String</SPAN> passage)
    {
        <SPAN class="code-comment">// No misspelled words <SPAN class="code-keyword">for</SPAN> an empty string.
</SPAN>        <SPAN class="code-keyword">if</SPAN> ((passage == <SPAN class="code-keyword">null</SPAN>) || (passage.length() == 0))
        {
            <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">null</SPAN>;
        }

        ArrayList errorList = <SPAN class="code-keyword">new</SPAN> ArrayList();

        <SPAN class="code-comment">// Tokenize the passage using spaces and punctionation.
</SPAN>        StringTokenizer st = <SPAN class="code-keyword">new</SPAN> StringTokenizer(passage, <SPAN class="code-quote">&quot; ,.!?;:&quot;</SPAN>);

        <SPAN class="code-comment">// Lock the service list.
</SPAN>        <SPAN class="code-keyword">synchronized</SPAN> (m_svcObjList)
        {
            <SPAN class="code-comment">// Loop through each word in the passage.
</SPAN>            <SPAN class="code-keyword">while</SPAN> (st.hasMoreTokens())
            {
                <SPAN class="code-object">String</SPAN> word = st.nextToken();

                <SPAN class="code-object">boolean</SPAN> correct = <SPAN class="code-keyword">false</SPAN>;

                <SPAN class="code-comment">// Check each available dictionary <SPAN class="code-keyword">for</SPAN> the current word.
</SPAN>                <SPAN class="code-keyword">for</SPAN> (<SPAN class="code-object">int</SPAN> i = 0; (!correct) &amp;&amp; (i &lt; m_svcObjList.size()); i++)
                {
                    DictionaryService dictionary =
                        (DictionaryService) m_svcObjList.get(i);

                    <SPAN class="code-keyword">if</SPAN> (dictionary.checkWord(word))
                    {
                        correct = <SPAN class="code-keyword">true</SPAN>;
                    }
                }

                <SPAN class="code-comment">// If the word is not correct, then add it
</SPAN>                <SPAN class="code-comment">// to the incorrect word list.
</SPAN>                <SPAN class="code-keyword">if</SPAN> (!correct)
                {
                    errorList.add(word);
                }
            }
        }

        <SPAN class="code-comment">// Return <SPAN class="code-keyword">null</SPAN> <SPAN class="code-keyword">if</SPAN> no words are incorrect.
</SPAN>        <SPAN class="code-keyword">if</SPAN> (errorList.size() == 0)
        {
            <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">null</SPAN>;
        }

        <SPAN class="code-comment">// Return the array of incorrect words.
</SPAN>        <SPAN class="code-keyword">return</SPAN> (<SPAN class="code-object">String</SPAN>[]) errorList.toArray(<SPAN class="code-keyword">new</SPAN> <SPAN class="code-object">String</SPAN>[errorList.size()]);
    }
}
</PRE>
</DIV></DIV>

<P>Notice how much simpler this service implementation is when compared to the same service implemented in Example 6. There are no references to OSGi interfaces in our application code and all tricky and complex code dealing with monitoring of services is handled for us. We must still create a <TT>manifest.mf</TT> file that contains the meta-data for the bundle; the manifest file is as follows:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>Bundle-Activator: tutorial.example8.Activator
Import-Package: tutorial.example2.service, tutorial.example6.service,
 org.apache.felix.servicebinder
Bundle-Name: Service Binder Spell checker service
Bundle-Description: A bundle that implements a simple spell checker service
Bundle-Vendor: Apache Felix
Bundle-Version: 1.0.0
Metadata-Location: tutorial/example8/metadata.xml
</PRE>
</DIV></DIV>

<P>We specify which class is used to activate the bundle via the <TT>Bundle-Activator</TT> attribute and also specify that the bundle imports the spell checker, dictionary, and Service Binder packages. (Note: Make sure your manifest file ends in a trailing carriage return or else the last line will be ignored.)</P>

<P>To compile the source code, we must include the <TT>felix.jar</TT> file (found in Felix' <TT>lib</TT> directory), the servicebinder.jar file, the example2.jar file, and the example6.jar file in the class path. We compile the source file using a command like:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>javac -d c:\classes *.java
</PRE>
</DIV></DIV>

<P>This command compiles all source files and outputs the generated classes into a subdirectory of the <TT>c:\classes</TT> directory; this subdirectory is <TT>tutorial\example8</TT>, named after the package we specified in the source file. For the above command to work, the <TT>c:\classes</TT> directory must exist.</P>

<P>Before we can create our bundle JAR file, we must copy the bundle's service dependency meta-data file, called <TT>metadata.xml</TT> above, into the example class' package. Assuming that we used the above command to compile the bundle, then we should copy the <TT>metadata.xml</TT> file into <TT>c:\classes\tutorial\example8</TT>. Now we can create the JAR file for our bundle using the following command:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>jar cfm example8.jar manifest.mf -C c:\classes tutorial\example8
</PRE>
</DIV></DIV>

<P>This command creates a JAR file using the manifest file we created and includes all of the classes and resources in the <TT>tutorial\example8</TT> directory inside of the <TT>c:\classes</TT> directory. Once the JAR file is created, we are ready to install and start the bundle.</P>

<P>To run Felix, we follow the instructions described in usage.html. When we start Felix, it asks for a profile name, we will put all of our bundles in a profile named <TT>tutorial</TT>. After running Felix, we should stop all tutorial bundles except for the service bundles. Use the <TT>lb</TT> command to make sure that only the bundles from Example 2 and Example 2b are active; use the <TT>start</TT> and <TT>stop</TT> commands as appropriate to start and stop the various tutorial bundles, respectively. (Note: Felix uses some bundles to provide its command shell, so do not stop these bundles.) We must also install the <TT>servicebinder.jar</TT> bundle that we downloaded at the beginning of this example. Assuming that we saved the bundle in our tutorial directory, we install the bundle using the following command:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>install file:/c:/tutorial/servicebinder.jar
</PRE>
</DIV></DIV>

<P>We do not need to start the Service Binder bundle, because it is only a library. Now we can install and start our spell checker service bundle. Assuming that we created our bundle in the directory <TT>c:\tutorial</TT>, we can install and start it in Felix' shell using the following command:</P>

<DIV class="preformatted panel" style="border-width: 1px;"><DIV class="preformattedContent panelContent">
<PRE>start file:/c:/tutorial/example8.jar
</PRE>
</DIV></DIV>

<P>The above command installs and starts the bundle in a single step; it is also possible to install and start the bundle in two steps by using the Felix <TT>install</TT> and <TT>start</TT> shell commands. To stop the bundle, use the Felix <TT>stop</TT> shell command. Use the Felix shell <TT>lb</TT> command to get the bundle identifier number for the spell checker service bundle to stop and restart it at will using the <TT>stop</TT> and <TT>start</TT> commands, respectively. Using the <TT>services</TT> command, we can see which services are currently available in the OSGi framework, including our dictionary and spell checker services. We can experiment with our spell checker service's dynamic availability by stopping the dictionary service bundles; when both dictionary services are stopped, the services command will reveal that our bundle is no longer offering its spell checker service. Likewise, when the dictionary services comeback, so will our spell checker service. This bundle will work with the spell checker client bundle that we created in Example 7, so feel free to experiment. To exit Felix, use the <TT>shutdown</TT> command.</P>

<P><EM>[Note: The spell checker client bundle in Example 7 could also be re-implemented using the Service Binder approach outlined in this example. The spell checker client has a one-to-one, dynamic service dependency on the spell checker service. Further, an entire application of instances could be described in a single <TT>metadata.xml</TT> in a single bundle or across a collection of bundles and the Service Binder will automatically manage the service dependencies among them.]</EM></P>
        <DIV class="timestamp" style="margin-top: 30px; font-size: 80%; text-align: right;">
Last modified by heavy@ungoverned.org on 2011-03-17 10:49:58.0
        </DIV>
        <DIV class="trademarkFooter">
Apache Felix, Felix, Apache, the Apache feather logo, and the Apache Felix project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners.
        </DIV>
    </DIV>
  </BODY>
</HTML>
